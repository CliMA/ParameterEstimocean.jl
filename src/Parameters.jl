module Parameters

export FreeParameters, lognormal, ScaledLogitNormal

using Oceananigans.Architectures: CPU, on_architecture, architecture
using Oceananigans.Utils: prettysummary
using Oceananigans.TurbulenceClosures: AbstractTurbulenceClosure, ScalarDiffusivity
using Oceananigans.TurbulenceClosures: AbstractTimeDiscretization, ExplicitTimeDiscretization

using Printf
using Distributions
using DocStringExtensions
using LinearAlgebra
using OrderedCollections

using SpecialFunctions: erfinv
using Distributions: AbstractRNG, ContinuousUnivariateDistribution

#####
##### Priors
#####

"""
    lognormal(; mean, std)

Return `Lognormal` distribution parameterized by 
the distribution `mean` and standard deviation `std`.

Notes
=====

A variate `X` is `LogNormal` distributed if

```math
\\log(X) âˆ¼ ğ’©(Î¼, ÏƒÂ²) ,
```

where ``ğ’©(Î¼, ÏƒÂ²)`` is the `Normal` distribution with mean ``Î¼``
and variance ``ÏƒÂ²``.

The `mean` and variance ``sÂ²`` (where ``s`` is the standard
deviation or `std`) are related to the parameters ``Î¼``
and ``ÏƒÂ²`` via

```math
 m = \\exp(Î¼ + ÏƒÂ² / 2),
```
```math
sÂ² = [\\exp(ÏƒÂ²) - 1] mÂ².
```

These formula allow us to calculate ``Î¼`` and ``Ïƒ`` given
``m`` and ``sÂ²``, since rearranging the formula for ``sÂ²``
gives

```math
\\exp(ÏƒÂ²) = mÂ² / sÂ² + 1
```

which then yields

```math
Ïƒ = \\sqrt{\\log(mÂ² / sÂ² + 1)}.
```

We then find that

```math
Î¼ = \\log(m) - ÏƒÂ² / 2 .
```

See also
[wikipedia](https://en.wikipedia.org/wiki/Log-normal_distribution#Generation_and_parameters).
"""
function lognormal(; mean, std)
    k = std^2 / mean^2 + 1 # intermediate variable
    Ïƒ = sqrt(log(k))
    Î¼ = log(mean) - Ïƒ^2 / 2
    return LogNormal(Î¼, Ïƒ)
end

struct ScaledLogitNormal{T} <: ContinuousUnivariateDistribution
    Î¼ :: T
    Ïƒ :: T
    lower_bound :: T
    upper_bound :: T

    ScaledLogitNormal{T}(Î¼, Ïƒ, L, U) where T = new{T}(T(Î¼), T(Ïƒ), T(L), T(U))
end

"""Return a logit-normally distributed variate given the normally-distributed variate `X`."""
normal_to_scaled_logit_normal(L, U, X) = L + (U - L) / (1 + exp(X))

"""Return a normally-distributed variate given the logit-normally distributed variate `Y`."""
scaled_logit_normal_to_normal(L, U, Y) = log((U - Y) / (Y - L))

Base.rand(rng::AbstractRNG, d::ScaledLogitNormal) =
    normal_to_scaled_logit_normal(d.lower_bound, d.upper_bound, rand(rng, Normal(d.Î¼, d.Ïƒ)))

unit_normal_std(mass) = 1 / (2 * âˆš2 * erfinv(mass))

"""
    ScaledLogitNormal([FT=Float64;] bounds=(0, 1), mass=0.5, interval=nothing, Î¼=nothing, Ïƒ=nothing)

Return a `ScaledLogitNormal` distribution with compact support within `bounds`.

`interval` is an optional 2-element tuple or Array. When specified,
the parameters `Î¼` and `Ïƒ` of the underlying `Normal` distribution
are calculated so that `mass` fraction of the probability density
lies within `interval`.

If `interval` is not specified, then `Î¼=0` and `Ïƒ=1` by default.

Notes
=====

`ScaledLogitNormal` is a four-parameter distribution
generated by the transformation

```math
Y = L + (U - L) / [1 + \\exp(X)],
```

of the normally-distributed variate ``X âˆ¼ ğ’©(Î¼, Ïƒ)``. The four parameters
governing the distribution of ``Y`` are thus

- ``L``:  lower bound (0 for the `LogitNormal` distribution)
- ``U``:  upper bound (1 for the `LogitNormal` distribution)
- ``Î¼``:  mean of the underlying `Normal` distribution
- ``ÏƒÂ²``: variance of the underlying `Normal` distribution
"""
function ScaledLogitNormal(FT=Float64; bounds=(0, 1), mass=0.5, interval=nothing, Î¼=nothing, Ïƒ=nothing)
    L, U = bounds

    if isnothing(interval) # use default Î¼=0 and Ïƒ=1 if not set
        isnothing(Î¼) && (Î¼ = 0)
        isnothing(Ïƒ) && (Ïƒ = 1)

    elseif !isnothing(interval) # try to compute Î¼ and Ïƒ

        Li, Ui = interval

        # User friendliness
        (!isnothing(Î¼) || !isnothing(Ïƒ)) && @warn "Using interval and mass to determine Î¼ and Ïƒ."
        0 < mass < 1 || throw(ArgumentError("Mass must lie between 0 and 1."))
        Li > L && Ui < U || throw(ArgumentError("Interval limits must lie between `bounds`."))

        # Compute lower and upper limits of midspread in unconstrained space
        #
        # Note that the _lower_ bound in unconstrained space is associated with the
        # _upper_ bound in constrained space, and vice versa.
        LÌƒi = scaled_logit_normal_to_normal(L, U, Ui)
        UÌƒi = scaled_logit_normal_to_normal(L, U, Li)
        
        Î¼ = (UÌƒi + LÌƒi) / 2

        # Note that the mass beneath a half-width `Î´` of the
        # standard Normal distribution is
        #
        # mass = 2 / âˆš(2Ï€) âˆ«â‚€áµŸ exp(-x^2 / 2) dx
        #      = erf(Î´ / âˆš2)
        #
        # For an `interval = (UÌƒi, LÌƒi)` of the normal distribution,
        # the non-dimensional half-width is
        #
        # Î´ = (UÌƒi - LÌƒi) / 2Ïƒ
        #
        # where Ïƒ is the distribution's standard deviation.
        # We then find
        #
        # erfinv(mass) = (UÌƒi - LÌƒi) / (2 * âˆš2 * Ïƒ) ,
        #
        # and rearranging to solve for Ïƒ yields
        # 
        Ïƒ = (UÌƒi - LÌƒi) / (2 * âˆš2 * erfinv(mass))
    end

    return ScaledLogitNormal{FT}(Î¼, Ïƒ, L, U)
end

# Calculate the prior in unconstrained space given a prior in constrained space
unconstrained_prior(Î ::LogNormal)         = Normal(Î .Î¼ / abs(Î .Î¼), Î .Ïƒ / abs(Î .Î¼))
unconstrained_prior(Î ::Normal)            = Normal(0, 1)
unconstrained_prior(Î ::ScaledLogitNormal) = Normal(Î .Î¼, Î .Ïƒ)

"""
    transform_to_unconstrained(Î , Y)

Transform the "constrained" (physical) variate `Y` into it's
unconstrained (normally-distributed) counterpart `X` through the
forward map associated with `Î `.

If some mapping between ``Y`` and the normally-distributed ``X`` is
defined via

```math
Y = g(X).
```

Then `transform_to_unconstrained` is the inverse ``X = g^{-1}(Y)``.
The change of variables ``g(X)`` determines the distribution `Î ` of `Y`.

Example
=======

The logarithm of a `LogNormal(Î¼, Ïƒ)` distributed variate is normally-distributed,
such that the forward trasform ``f â‰¡ \\exp``,

```math
Y = \\exp(X),
```

and the inverse trasnform is the natural logarithm ``f^{-1} â‰¡ \\log``,

```math
\\log(Y) = X âˆ¼ ğ’©(Î¼, Ïƒ).
```
"""
transform_to_unconstrained(Î ::Normal,    Y) = (Y - Î .Î¼) / Î .Ïƒ
transform_to_unconstrained(Î ::LogNormal, Y) = log(Y^(1 / abs(Î .Î¼))) # log(Y) / abs(Î .Î¼)
transform_to_unconstrained(Î ::ScaledLogitNormal, Y) =
    scaled_logit_normal_to_normal(Î .lower_bound, Î .upper_bound, Y)

"""
    transform_to_constrained(Î , X)

Transform an "unconstrained", normally-distributed variate `X`
to "constrained" (physical) space via the map associated with
the distribution `Î ` of `Y`. 
"""
transform_to_constrained(Î ::Normal, X)    = X * Î .Ïƒ + Î .Î¼
transform_to_constrained(Î ::LogNormal, X) = exp(X * abs(Î .Î¼))
transform_to_constrained(Î ::ScaledLogitNormal, X) =
    normal_to_scaled_logit_normal(Î .lower_bound, Î .upper_bound, X)

# Convenience vectorized version
transform_to_constrained(priors::NamedTuple, X::AbstractVector) =
    NamedTuple(name => transform_to_constrained(priors[name], X[i])
               for (i, name) in enumerate(keys(priors)))

# Convenience matrixized version assuming particles vary on 2nd dimension
transform_to_constrained(priors::NamedTuple, X::AbstractMatrix) =
    [transform_to_constrained(priors, X[:, k]) for k = 1:size(X, 2)]

function inverse_covariance_transform(Î , X, covariance)
    diag = [covariance_transform_diagonal(Î [i], X[i]) for i=1:length(Î )]
    dT = Diagonal(diag)
    return dT * covariance * dT'
end

covariance_transform_diagonal(::LogNormal, X) = exp(X)
covariance_transform_diagonal(::Normal, X)    = 1
covariance_transform_diagonal(Î ::ScaledLogitNormal, X) = - (Î .upper_bound - Î .lower_bound) * exp(X) / (1 + exp(X))^2

# TODO: add docstring
# TODO: Also use in EKI constructor?
function random_unconstrained_parameters(free_parameters, Nens)
    priors = free_parameters.priors
    NÎ¸ = length(free_parameters.names)
    unconstrained_priors = NamedTuple(name => unconstrained_prior(priors[name])
                                      for name in free_parameters.names)

    X = [rand(unconstrained_priors[i]) for i=1:NÎ¸, k=1:Nens]

    return X[:]
end

#####
##### Free parameters
#####

"""
    struct FreeParameters{N, P, D}

A container for free parameters that includes the parameter names and their
corresponding prior distributions.

$(FIELDS)
"""
struct FreeParameters{N, P, D}
    "free parameters"
    names :: N
    "prior distributions for free parameters"
    priors :: P
    "dependent parameters"
    dependent_parameters :: D
end

"""
    FreeParameters(priors; names = Symbol.(keys(priors)), dependent_parameters = NamedTuple())

Return named `FreeParameters` with priors. Free parameter `names` are inferred from
the keys of `priors` if not provided. Optionally, `dependent_parameters` are prescribed
as a `NamedTuple` whose keys are the names of "additional" parameters, and whose values
are functions that return those parameters given a vector of free parameters in `names`.

Example
=======

```jldoctest
julia> using Distributions, ParameterEstimocean

julia> priors = (Î½ = Normal(1e-4, 1e-5), Îº = Normal(1e-3, 1e-5))
(Î½ = Normal{Float64}(Î¼=0.0001, Ïƒ=1.0e-5), Îº = Normal{Float64}(Î¼=0.001, Ïƒ=1.0e-5))

julia> free_parameters = FreeParameters(priors)
FreeParameters with 2 free parameters and 0 dependent parameters
â”œâ”€â”€ names: (:Î½, :Îº)
â””â”€â”€ priors:
    â”œâ”€â”€ Î½ => Normal{Float64}(Î¼=0.0001, Ïƒ=1.0e-5)
    â””â”€â”€ Îº => Normal{Float64}(Î¼=0.001, Ïƒ=1.0e-5)

julia> c(p) = p.Î½ + p.Îº # compute a third dependent parameter `c` as a function of `Î½` and `Îº`
c (generic function with 1 method)

julia> free_parameters_with_a_dependent = FreeParameters(priors, dependent_parameters=(; c))
FreeParameters with 2 free parameters and 1 dependent parameter
â”œâ”€â”€ names: (:Î½, :Îº)
â”œâ”€â”€ priors:
â”‚   â”œâ”€â”€ Î½ => Normal{Float64}(Î¼=0.0001, Ïƒ=1.0e-5)
â”‚   â””â”€â”€ Îº => Normal{Float64}(Î¼=0.001, Ïƒ=1.0e-5)
â””â”€â”€ dependent parameters:
    â””â”€â”€ c => c (generic function with 1 method)
```
"""
function FreeParameters(priors; names = Symbol.(keys(priors)), dependent_parameters = NamedTuple())
    priors = NamedTuple(name => priors[name] for name in names)
    return FreeParameters(Tuple(names), priors, dependent_parameters)
end

Base.summary(fp::FreeParameters) = "$(fp.names)"

function prior_show(io, priors, name, prefix, width)
    print(io, @sprintf("%s %s => ", prefix, lpad(name, width, " ")))
    show(io, priors[name])
    return nothing
end

function dependent_parameter_show(io, dependent_parameters, name, prefix, width)
    print(io, @sprintf("%s %s => ", prefix, lpad(name, width, " ")))
    print(io, prettysummary(dependent_parameters[name]))
    return nothing
end

parameter_str(N) = N == 1 ? "parameter" : "parameters"

function Base.show(io::IO, p::FreeParameters)
    Np, Nd = length(p), length(p.dependent_parameters)

    free_parameters_summary = "$Np free " * parameter_str(Np)
    dependent_parameters_summary = "$Nd dependent " * parameter_str(Nd)

    title = "FreeParameters with " * free_parameters_summary * 
            " and " * dependent_parameters_summary

    Nd = length(p.dependent_parameters)
    prefix = Nd > 0 ? "â”œ" : "â””"

    print(io, title, '\n',
              "â”œâ”€â”€ names: $(p.names)", '\n',
              prefix * "â”€â”€ priors: ")

    maximum_name_length = maximum([length(string(name)) for name in p.names]) 

    for (i, name) in enumerate(p.names[1:end])
        bufferprefixprefix = Nd
        if isempty(p.dependent_parameters)
            prefix = i == length(p.names) ? "    â””â”€â”€" : "    â”œâ”€â”€"
        else !isempty(p.dependent_parameters)
            prefix = i == length(p.names) ? "â”‚   â””â”€â”€" : "â”‚   â”œâ”€â”€"
        end
        print(io, '\n')
        prior_show(io, p.priors, name, prefix, maximum_name_length)
    end
    
    if !isempty(p.dependent_parameters)
        print(io, '\n')
        print(io, "â””â”€â”€ dependent parameters: ")

        maximum_name_length = maximum([length(string(name)) for name in p.dependent_parameters]) 

        for (i, name) in enumerate(propertynames(p.dependent_parameters))
            prefix = i == length(p.dependent_parameters) ? "    â””â”€â”€" : "    â”œâ”€â”€"
            print(io, '\n')
            dependent_parameter_show(io, p.dependent_parameters, name, prefix, maximum_name_length)
        end
    end

    return nothing
end

Base.length(p::FreeParameters) = length(p.names)

function build_parameters_named_tuple(p::FreeParameters, free_Î¸; with_dependent_parameters=true)
    if free_Î¸ isa Dict # convert to NamedTuple with
        free_Î¸ = NamedTuple(name => free_Î¸[name] for name in p.names)
    elseif !(free_Î¸ isa NamedTuple) # mostly likely a Vector: convert to NamedTuple with
        free_Î¸ = NamedTuple{p.names}(Tuple(free_Î¸))
    end

    if with_dependent_parameters
        # Compute dependent parameters
        dependent_names = keys(p.dependent_parameters) 
        maps = p.dependent_parameters
        dependent_Î¸ = NamedTuple(name => maps[name](free_Î¸) for name in dependent_names)

        return merge(dependent_Î¸, free_Î¸) # prioritize free_Î¸
    else
        return free_Î¸
    end
end

#####
##### Setting parameters
#####

const ParameterValue = Union{Number, AbstractArray}

"""
    construct_object(specification_dict, parameters; name=nothing, type_parameters=nothing)
    
    construct_object(d::ParameterValue, parameters; name=nothing)

Return a composite type object whose properties are prescribed by the `specification_dict`
dictionary. All parameter values are given the values in `specification_dict` *unless* they
are included as a parameter name-value pair in the named tuple `parameters`, in which case
the value in `parameters` is asigned.

The `construct_object` is recursively called upon every property that is included in `specification_dict`
until a property with a numerical value is reached. The object's constructor name must be
included in `specification_dict` under key `:type`.

Example
=======

```jldoctest; filter = [r".*Dict{Symbol.*", r".*:type       => Closure.*", r".*:c          => 3.*", r".*:subclosure => Dict{Symbol.*"]
julia> using ParameterEstimocean.Parameters: construct_object, dict_properties, closure_with_parameters

julia> struct Closure; subclosure; c end

julia> struct ClosureSubModel; a; b end

julia> sub_closure = ClosureSubModel(1, 2)
ClosureSubModel(1, 2)

julia> closure = Closure(sub_closure, 3)
Closure(ClosureSubModel(1, 2), 3)

julia> specification_dict = dict_properties(closure)
Dict{Symbol, Any} with 3 entries:
  :type       => Closure
  :c          => 3
  :subclosure => Dict{Symbol, Any}(:a=>1, :b=>2, :type=>ClosureSubModel)

julia> new_closure = construct_object(specification_dict, (a=2.1,))
Closure(ClosureSubModel(2.1, 2), 3)
  
julia> another_new_closure = construct_object(specification_dict, (b=Ï€, c=2Ï€))
Closure(ClosureSubModel(1, Ï€), 6.283185307179586)
```
"""
construct_object(d, parameters; name=nothing) = d # fallback
construct_object(d::ParameterValue, parameters; name=nothing) =
    name âˆˆ keys(parameters) ? getproperty(parameters, name) : d # replace parameter values with new ones

function construct_object(specification_dict::OrderedDict, parameters; name=nothing, type_parameters=nothing)

    type = Constructor = specification_dict[:type]

    # Recurisve construction
    if type === NamedTuple
        return NamedTuple(name => construct_object(specification_dict[name], parameters; name)
                          for name in keys(specification_dict) if name != :type)
    else
        
        # if name != :type]
        kwargs_vector = [construct_object(specification_dict[name], parameters; name) for name in fieldnames(type)]
    
        return isnothing(type_parameters) ? Constructor(kwargs_vector...) : Constructor{type_parameters...}(kwargs_vector...)
   end
end

"""
    dict_properties(object)

Return a dictionary with all properties of an `object` and their values, including the 
`object`'s type name. If any of the `object`'s properties is not a numerical value but
instead a composite type, then `dict_properties` is called recursively on that `object`'s
property returning a dictionary with all properties of that composite type. Recursion
ends when properties of type `ParameterValue` are found.
"""
function dict_properties(object)
    p = OrderedDict{Symbol, Any}(n => dict_properties(getproperty(object, n)) for n in propertynames(object))
    p[:type] = typeof(object).name.wrapper
    return p
end

dict_properties(object::ParameterValue) = object
dict_properties(object::NamedTuple) = object
dict_properties(object::Function) = object

"""
    closure_with_parameters(closure, parameters)

Return a new object where for each (`parameter_name`, `parameter_value`) pair 
in `parameters`, the value corresponding to the key in `closure` that matches
`parameter_name` is replaced with `parameter_value`.

Example
=======

Create a placeholder `Closure` type that includes a parameter `c` and a sub-closure
with two parameters: `a` and `b`. Then construct a closure with values `a, b, c = 1, 2, 3`.

```jldoctest closure_with_parameters
julia> struct Closure; subclosure; c end

julia> struct ClosureSubModel; a; b end

julia> sub_closure = ClosureSubModel(1, 2)
ClosureSubModel(1, 2)

julia> closure = Closure(sub_closure, 3)
Closure(ClosureSubModel(1, 2), 3)
```

Providing `closure_with_parameters` with a named tuple of parameter names and values,
and a recursive search in all types and subtypes within `closure` is done and whenever
a parameter is found whose name exists in the named tuple we provided, its value is 
then replaced with the value provided.

```jldoctest closure_with_parameters
julia> new_parameters = (a = 12, d = 7)
(a = 12, d = 7)

julia> using ParameterEstimocean.Parameters: closure_with_parameters

julia> closure_with_parameters(closure, new_parameters)
Closure(ClosureSubModel(12, 2), 3)
```
"""
closure_with_parameters(closure, parameters) = construct_object(dict_properties(closure), parameters)
closure_with_parameters(closure, ::Nothing) = nothing

closure_with_parameters(closure::AbstractTurbulenceClosure{ExplicitTimeDiscretization}, parameters) =
    construct_object(dict_properties(closure), parameters, type_parameters=nothing)

closure_with_parameters(closure::AbstractTurbulenceClosure{TD}, parameters) where {TD <: AbstractTimeDiscretization} =
    construct_object(dict_properties(closure), parameters; type_parameters=tuple(TD))

closure_with_parameters(closure::ScalarDiffusivity{TD, F}, parameters) where {TD, F} =
    construct_object(dict_properties(closure), parameters; type_parameters=(TD, F))

closure_with_parameters(closures::Tuple, parameters) =
    Tuple(closure_with_parameters(closure, parameters) for closure in closures)

"""
    update_closure_ensemble_member!(closures, k, Î¸â‚–)

Use `parameters` to update the `k`-th closure from and array of `closures`.
The `k`-th closure corresponds to ensemble member `k`.
"""
update_closure_ensemble_member!(closure, k, Î¸â‚–) = nothing

update_closure_ensemble_member!(closures::AbstractVector, k, Î¸â‚–) =
    closures[k] = closure_with_parameters(closures[k], Î¸â‚–)

function update_closure_ensemble_member!(closures::AbstractMatrix, k, Î¸â‚–)
    for j in 1:size(closures, 2) # Assume that ensemble varies along first dimension
        closures[k, j] = closure_with_parameters(closures[k, j], Î¸â‚–)
    end
    
    return nothing
end

function update_closure_ensemble_member!(closure_tuple::Tuple, k, Î¸â‚–)
    for closure in closure_tuple
        update_closure_ensemble_member!(closure, k, Î¸â‚–)
    end
    return nothing
end

"""
    new_closure_ensemble(closures, parameter_ensemble, arch=CPU())

Return a new set of `closures` in which all closures that have free parameters are updated.
Closures with free parameters are expected as `AbstractArray` of `TurbulenceClosures`, and
this allows `new_closure_ensemble` to go through all closures in `closures` and only update
the parameters for the any closure that is of type `AbstractArray`. The `arch`itecture
(`CPU()` or `GPU()`) defines whethere `Array` or `CuArray` is returned.
"""
function new_closure_ensemble(closures::AbstractArray, parameter_ensemble, arch)
    cpu_closures = on_architecture(CPU(), closures)

    for (k, Î¸â‚–) in enumerate(parameter_ensemble)
        update_closure_ensemble_member!(cpu_closures, k, Î¸â‚–)
    end

    return on_architecture(arch, cpu_closures)
end

new_closure_ensemble(closures::Tuple, parameter_ensemble, arch) = 
    Tuple(new_closure_ensemble(closure, parameter_ensemble, arch) for closure in closures)

# Don't change closure if parameters=nothing
new_closure_ensemble(closure::Union{Tuple, AbstractArray}, ::Nothing, arch) = closure
new_closure_ensemble(closure, parameter_ensemble, arch) = closure

end # module
