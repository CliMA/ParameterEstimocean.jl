var documenterSearchIndex = {"docs":
[{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"EditURL = \"https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/blob/main/examples/perfect_catke_calibration.jl\"","category":"page"},{"location":"literated/perfect_catke_calibration/#Perfect-CAKTE-calibration-with-Ensemble-Kalman-Inversion","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"","category":"section"},{"location":"literated/perfect_catke_calibration/#Install-dependencies","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Install dependencies","text":"","category":"section"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"using Pkg\npkg\"add OceanTurbulenceParameterEstimation, Oceananigans, Distributions, CairoMakie\"","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"using OceanTurbulenceParameterEstimation, LinearAlgebra, CairoMakie\n\nusing OceanTurbulenceParameterEstimation.Transformations: Transformation\nusing Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities: CATKEVerticalDiffusivity, MixingLength, SurfaceTKEFlux","category":"page"},{"location":"literated/perfect_catke_calibration/#Perfect-observations-of-CATKE-driven-mixing","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect observations of CATKE-driven mixing","text":"","category":"section"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"Our first task is to generate synthetic observations, using a one-dimensional model driven by surface fluxes and with turbulent mixing parameterized by CATKE. We use a simplified CATKE with no stability function (by setting C·¥∑u ≥ = C·¥∑c ≥ = C·¥∑e ≥ = 0) and \"reasonable\", but unrealistic parameters. We will only attempt to calibrate a subset of the parameters that we set to generate the observations.","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"# Load utilities\nexamples_path = joinpath(pathof(OceanTurbulenceParameterEstimation), \"..\", \"..\", \"examples\")\ninclude(joinpath(examples_path, \"intro_to_inverse_problems.jl\"))\n\nmixing_length = MixingLength(C·¥¨u  = 0.0,\n                             C·¥¨c  = 1.0,\n                             C·¥¨e  = 0.0,\n                             C·¥∑u‚Åª = 0.1,\n                             C·¥∑c‚Åª = 0.1,\n                             C·¥∑e‚Åª = 0.1,\n                             C·¥∑u ≥ = 0.0,\n                             C·¥∑c ≥ = 0.0,\n                             C·¥∑e ≥ = 0.0)\n\ncatke = CATKEVerticalDiffusivity(mixing_length=mixing_length)\n\n# Specify both wind mixing and convection:\ndata_path = generate_synthetic_observations(\"catke\",\n                                            closure = catke,\n                                            tracers = (:b, :e),\n                                            Nz = 32,\n                                            Lz = 64,\n                                            Œît = 10.0,\n                                            stop_time = 12hours,\n                                            overwrite = true,\n                                            Q·µò = -1e-4,\n                                            Q·µá = 1e-8,\n                                            N¬≤ = 1e-5)","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"Next, we load and inspect the observations to make sure they're sensible:","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"transformation = (u = ZScore(),\n                  v = ZScore(),\n                  b = ZScore(),\n                  e = RescaledZScore(1e-1))\n\nobservations = SyntheticObservations(data_path; field_names=(:u, :v, :b, :e), transformation)\n\nfig = Figure()\n\nax_b = Axis(fig[1, 1], xlabel = \"Buoyancy\\n[10‚Åª‚Å¥ m s‚Åª¬≤]\", ylabel = \"z [m]\")\nax_u = Axis(fig[1, 2], xlabel = \"Velocities\\n[cm s‚Åª¬π]\")\nax_e = Axis(fig[1, 3], xlabel = \"Turbulent kinetic energy\\n[cm¬≤ s‚Åª¬≤]\")\n\nz = znodes(Center, observations.grid)\n\ncolorcycle = [:black, :red, :blue, :orange, :pink]\n\nfor i = 1:length(observations.times)\n    b = observations.field_time_serieses.b[i]\n    e = observations.field_time_serieses.e[i]\n    u = observations.field_time_serieses.u[i]\n    v = observations.field_time_serieses.v[i]\n    t = observations.times[i]\n\n    label = \"t = \" * prettytime(t)\n    u_label = i == 1 ? \"u, \" * label : label\n    v_label = i == 1 ? \"v, \" * label : label\n    # Note unit conversions below, eg m s‚Åª¬≤ -> 10‚Åª‚Å¥ m s‚Åª¬≤\n    lines!(ax_b, 1e4 * interior(b)[1, 1, :], z; label, color=colorcycle[i])\n    lines!(ax_u, 1e2 * interior(u)[1, 1, :], z; linestyle=:solid, color=colorcycle[i], label=u_label)\n    lines!(ax_u, 1e2 * interior(v)[1, 1, :], z; linestyle=:dash, color=colorcycle[i], label=v_label)\n    lines!(ax_e, 1e4 * interior(e)[1, 1, :], z; label, color=colorcycle[i])\nend\n\naxislegend(ax_b, position=:rb)\naxislegend(ax_u, position=:lb, merge=true)\naxislegend(ax_e, position=:rb)\n\n##display(fig)\n\nsave(\"synthetic_catke_observations.svg\", fig); nothing # hide","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"Well, that looks like a boundary layer, in some respects.","category":"page"},{"location":"literated/perfect_catke_calibration/#Calibration","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Calibration","text":"","category":"section"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"Next, we build a simulation of an ensemble of column models to calibrate CATKE using Ensemble Kalman Inversion.","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"architecture = CPU()\nensemble_simulation, closure‚òÖ = build_ensemble_simulation(observations, architecture; Nensemble=20)","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"We choose to calibrate a subset of the CATKE parameters,","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"priors = (C·¥¨u = lognormal(mean=0.05, std=0.05),\n          C·¥¨c = lognormal(mean=0.8,  std=0.1),\n          C·¥¨e = lognormal(mean=0.1,  std=0.05))\n\nfree_parameters = FreeParameters(priors)","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"The handy utility function build_ensemble_simulation also tells us the optimal parameters that were used when generating the synthetic observations:","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"@show Œ∏‚òÖ = (C·¥¨u = closure‚òÖ.mixing_length.C·¥¨u,\n            C·¥¨c = closure‚òÖ.mixing_length.C·¥¨c,\n            C·¥¨e = closure‚òÖ.mixing_length.C·¥¨e)","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"We construct the InverseProblem from observations, ensemble_simulation, and free_parameters,","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"calibration = InverseProblem(observations, ensemble_simulation, free_parameters)","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"We can check that the first ensemble member of the mapped output, which was run with the \"true\" # parameters, is identical to the mapped observations:","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"G = forward_map(calibration, Œ∏‚òÖ)\ny = observation_map(calibration)\n\n@show G[:, 1] ‚âà y","category":"page"},{"location":"literated/perfect_catke_calibration/#Ensemble-Kalman-Inversion","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"","category":"section"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"Next, we construct an EnsembleKalmanInversion (EKI) object,","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"The calibration is done here using Ensemble Kalman Inversion. For more information about the algorithm refer to EnsembleKalmanProcesses.jl documentation.","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"eki = EnsembleKalmanInversion(calibration;\n                              noise_covariance = 1e-3,\n                              resampler = Resampler(acceptable_failure_fraction=0.3))","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"and perform few iterations to see if we can converge to the true parameter values.","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"iterate!(eki; iterations = 10)","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"Last, we visualize the outputs of EKI calibration.","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"# Convert everything to a vector\noptimal_Œ∏ = collect(values(Œ∏‚òÖ))\nensemble_mean_Œ∏ = map(summary -> collect(values(summary.ensemble_mean)), eki.iteration_summaries)\nŒ∏_variances = map(summary -> collect(values(summary.ensemble_var)), eki.iteration_summaries)\n\nabsolute_error = NamedTuple(name => map(Œ∏ -> Œ∏[p] - Œ∏‚òÖ[p], ensemble_mean_Œ∏) for (p, name) in enumerate(free_parameters.names))\nrelative_error = NamedTuple(name => abs.(absolute_error[name]) ./ Œ∏‚òÖ[name] for name in free_parameters.names)\n\noutput_distances = map(Œ∏ -> norm(forward_map(calibration, Œ∏)[:, 1:1] - y), ensemble_mean_Œ∏)\n\nfig = Figure()\n\nax_error = Axis(fig[1, 1], title = \"Parameter distance\", xlabel = \"Iteration\", ylabel = \"|‚ü®Œ∏‚Çô‚ü© - Œ∏‚òÖ| / Œ∏‚òÖ\")\n\nfor name in free_parameters.names\n    lines!(ax_error, 0:eki.iteration, parent(relative_error[name]), linewidth=2, label=string(name))\nend\n\naxislegend(ax_error, position=:rt)\n\nlines(fig[1, 2], 0:eki.iteration, parent(output_distances), color = :blue, linewidth = 2,\n      axis = (title = \"Output distance\", xlabel = \"Iteration\", ylabel = \"|G(‚ü®Œ∏‚Çô‚ü©) - y|\"))\n\nax3 = Axis(fig[2, 1:2], title = \"Parameter convergence\", xlabel = \"Iteration\",\n           ylabel = \"Relative change ensemble variance\", yscale = log10)\n\nfor (p, name) in enumerate(free_parameters.names)\n    Œ∏p_variances = [Œ∏_variances[iter][p] for iter = 0:eki.iteration]\n    lines!(ax3, 0:eki.iteration, parent(Œ∏p_variances / Œ∏p_variances[1]), label = String(name), linewidth = 2)\nend\n\naxislegend(ax3, position = :rt)\n\n##display(fig)\n\nsave(\"perfect_catke_calibration_summary.svg\", fig); nothing #hide","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"final_mean_Œ∏ = eki.iteration_summaries[end].ensemble_mean\nforward_run!(calibration, [Œ∏‚òÖ, final_mean_Œ∏])\n\ntime_series_collector = calibration.time_series_collector\ntimes = time_series_collector.times\n\n# Extract last save point and plot each solution component\nNt = length(times)\n\nb = time_series_collector.field_time_serieses.b[Nt]\ne = time_series_collector.field_time_serieses.e[Nt]\nu = time_series_collector.field_time_serieses.u[Nt]\nv = time_series_collector.field_time_serieses.v[Nt]\n\nt = times[Nt]\nz = znodes(b)\n\n# The ensemble varies along the first, or `x`-dimension:\nb‚òÖ = 1e4 * interior(b)[1, 1, :]  # convert units m s‚Åª¬≤ -> 10‚Åª‚Å¥ m s‚Åª¬≤\nb¬π = 1e4 * interior(b)[2, 1, :]  # convert units m s‚Åª¬≤ -> 10‚Åª‚Å¥ m s‚Åª¬≤\n\ne‚òÖ = 1e4 * interior(e)[1, 1, :]  # convert units m¬≤ s‚Åª¬≤ -> cm¬≤ s‚Åª¬≤\ne¬π = 1e4 * interior(e)[2, 1, :]  # convert units m¬≤ s‚Åª¬≤ -> cm¬≤ s‚Åª¬≤\n\nu‚òÖ = 1e2 * interior(u)[1, 1, :]  # convert units m s‚Åª¬π -> cm s‚Åª¬π\nu¬π = 1e2 * interior(u)[2, 1, :]  # convert units m s‚Åª¬π -> cm s‚Åª¬π\n\nv‚òÖ = 1e2 * interior(v)[1, 1, :]  # convert units m s‚Åª¬π -> cm s‚Åª¬π\nv¬π = 1e2 * interior(v)[2, 1, :]  # convert units m s‚Åª¬π -> cm s‚Åª¬π\n\nfig = Figure()\n\nax = Axis(fig[1, 1], xlabel = \"Buoyancy\\n[10‚Åª‚Å¥ m s‚Åª¬≤]\", ylabel = \"z [m]\")\nb‚òÖ_label = \"true b at \" * prettytime(t)\nb¬π_label = \"b with ‚ü®Œ∏‚ü©\"\nlines!(ax, b‚òÖ, z; label=b‚òÖ_label, linewidth=3)\nlines!(ax, b¬π, z; label=b¬π_label, linewidth=2)\naxislegend(ax, position=:lb)\n\nax = Axis(fig[1, 2], xlabel = \"Turbulent kinetic energy\\n[cm¬≤ s‚Åª¬≤]\")\ne‚òÖ_label = \"true e at \" * prettytime(t)\ne¬π_label = \"e with ‚ü®Œ∏‚ü©\"\nlines!(ax, e‚òÖ, z; label=e‚òÖ_label, linewidth=3)\nlines!(ax, e¬π, z; label=e¬π_label, linewidth=2)\naxislegend(ax, position=:lb)\n\nax = Axis(fig[1, 3], xlabel = \"Velocities\\n[cm s‚Åª¬π]\")\nu‚òÖ_label = \"true u at \" * prettytime(t)\nu¬π_label = \"u with ‚ü®Œ∏‚ü©\"\nv‚òÖ_label = \"true v\"\nv¬π_label = \"v with ‚ü®Œ∏‚ü©\"\nlines!(ax, u‚òÖ, z; label=u‚òÖ_label, linewidth=3)\nlines!(ax, u¬π, z; label=u¬π_label, linewidth=2)\nlines!(ax, v‚òÖ, z; label=v‚òÖ_label, linestyle=:dash, linewidth=3)\nlines!(ax, v¬π, z; label=v¬π_label, linestyle=:dash, linewidth=2)\naxislegend(ax, position=:lb)\n\nsave(\"perfect_catke_calibration_particle_realizations.svg\", fig); nothing # hide","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"##display(fig)","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"And also we plot the the distributions of the various model ensembles for few EKI iterations to see if and how well they converge to the true diffusivity values.","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"fig = Figure()\n\nax1 = Axis(fig[1, 1])\nax2 = Axis(fig[2, 1], xlabel = \"C·¥¨u\", ylabel = \"C·¥¨c\")\nax3 = Axis(fig[2, 2])\nscatters = []\nlabels = String[]\n\nfor iteration in [0, 1, 5, 10]\n    # Make parameter matrix\n    parameters = eki.iteration_summaries[iteration].parameters\n    Nensemble = length(parameters)\n    parameter_ensemble_matrix = [parameters[i][j] for i=1:Nensemble, j=1:2]\n\n    label = iteration == 0 ? \"Initial ensemble\" : \"Iteration $iteration\"\n    push!(labels, label)\n    push!(scatters, scatter!(ax2, parameter_ensemble_matrix))\n    density!(ax1, parameter_ensemble_matrix[:, 1])\n    density!(ax3, parameter_ensemble_matrix[:, 2], direction = :y)\nend\n\nvlines!(ax1, [Œ∏‚òÖ.C·¥¨u], color = :red)\nvlines!(ax2, [Œ∏‚òÖ.C·¥¨u], color = :red)\nhlines!(ax2, [Œ∏‚òÖ.C·¥¨c], color = :red)\nhlines!(ax3, [Œ∏‚òÖ.C·¥¨c], color = :red)\n\ncolsize!(fig.layout, 1, Fixed(300))\ncolsize!(fig.layout, 2, Fixed(200))\nrowsize!(fig.layout, 1, Fixed(200))\nrowsize!(fig.layout, 2, Fixed(300))\n\nLegend(fig[1, 2], scatters, labels, position = :lb)\n\nhidedecorations!(ax1, grid = false)\nhidedecorations!(ax3, grid = false)\n\n##display(fig)\n\nsave(\"perfect_catke_calibration_parameter_distributions.svg\", fig); nothing # hide","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"Hint: if using a REPL or notebook, try using Pkg; Pkg.add(\"ElectronDisplay\"); using ElectronDisplay; display(fig) To see the figure in a window.","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"","category":"page"},{"location":"literated/perfect_catke_calibration/","page":"Perfect CAKTE calibration with Ensemble Kalman Inversion","title":"Perfect CAKTE calibration with Ensemble Kalman Inversion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"installation_instructions/#Installation-instructions","page":"Installation Instructions","title":"Installation instructions","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"You can install the latest version of OceanTurbulenceParameterEstimation.jl via the built-in package manager (by pressing ] in the Julia REPL command prompt) to add the package and also to  instantiate/build all the required dependencies","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"To install, use Julia's  built-in package manager (accessed by pressing ] in the Julia REPL command prompt) to add the package and also to instantiate/build all the required dependencies. The package is not yet included in Julia's official registry so you need to install via Github.","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"To install a tagged version of the package, e.g., v0.6.0, use","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"julia>]\n(v1.6) pkg> add https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl#v0.6.0\n(v1.6) pkg> instantiate","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"Alternatively, if you'd like to be in the bleeding edge of the package's latest developments you may install the version on the #main branch (or any other branch or commit), e.g.","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"julia>]\n(v1.6) pkg> add https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl#main\n(v1.6) pkg> instantiate","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"EditURL = \"https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/blob/main/examples/intro_to_inverse_problems.jl\"","category":"page"},{"location":"literated/intro_to_inverse_problems/#Intro-to-InverseProblem","page":"Intro to inverse problems","title":"Intro to InverseProblem","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"This example illustrates the construction of an \"ensemble simulation\" that can evaluate an ensemble of column models given an ensemble of free parameter sets. The example then builds an InverseProblem from observations, an ensemble simulation, and a set of free parameters, and illustrates its basic usage.","category":"page"},{"location":"literated/intro_to_inverse_problems/#Install-dependencies","page":"Intro to inverse problems","title":"Install dependencies","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"using Pkg\npkg\"add OceanTurbulenceParameterEstimation, Oceananigans, Distributions, CairoMakie\"","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"First we load few things","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"using OceanTurbulenceParameterEstimation\n\nusing Oceananigans\nusing Oceananigans.Architectures: arch_array\nusing Oceananigans.Units\nusing Oceananigans.Models.HydrostaticFreeSurfaceModels: ColumnEnsembleSize\nusing Oceananigans.TurbulenceClosures: ConvectiveAdjustmentVerticalDiffusivity\n\nusing CairoMakie\nusing Distributions\nusing JLD2","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"We reuse some utilities from a previous example to build observations:","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"examples_path = joinpath(pathof(OceanTurbulenceParameterEstimation), \"..\", \"..\", \"examples\")\ninclude(joinpath(examples_path, \"intro_to_observations.jl\"))\ndata_path = generate_synthetic_observations()\nobservations = SyntheticObservations(data_path, field_names=:b, transformation=ZScore())","category":"page"},{"location":"literated/intro_to_inverse_problems/#Building-an-\"ensemble-simulation\"","page":"Intro to inverse problems","title":"Building an \"ensemble simulation\"","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"Our next task is to construct a parameterized Oceananigans.Simulation that generates the \"foward map\" for an ensemble of free parameter sets. To generate an ensemble of column model model outputs efficiently, we construct one 3D Oceananigans.Simulation consisting of Nx by Ny independent column models.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"The calibration problem then uses the ensemble simulation to find optimal parameters by minimizing the discrepency between the observations and the forward map.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"\"\"\"\n    extract_perfect_parameters(observations, Nensemble)\n\nExtract parameters from a batch of \"perfect\" observations.\n\"\"\"\nfunction extract_perfect_parameters(observations, Nensemble)\n    Nbatch = length(observations)\n    Q·µò, Q·µá, N¬≤, f = [zeros(Nensemble, Nbatch) for i = 1:4]\n\n    Nz = first(observations).grid.Nz\n    Hz = first(observations).grid.Hz\n    Lz = first(observations).grid.Lz\n    Œît = first(observations).metadata.parameters.Œît\n\n    for (j, obs) in enumerate(observations)\n        Q·µò[:, j] .= obs.metadata.parameters.Q·µò\n        Q·µá[:, j] .= obs.metadata.parameters.Q·µá\n        N¬≤[:, j] .= obs.metadata.parameters.N¬≤\n        f[:, j] .= obs.metadata.coriolis.f\n    end\n\n    file = jldopen(first(observations).path)\n    closure = file[\"serialized/closure\"]\n    close(file)\n\n    return Q·µò, Q·µá, N¬≤, f, Œît, Lz, Nz, Hz, closure\nend\n\n\"\"\"\n    build_ensemble_simulation(observations, arch=CPU(); Nensemble=1)\n\nReturns an `Oceananigans.Simulation` representing an `Nensemble √ó 1`\nensemble of column models designed to reproduce `observations`.\n\"\"\"\nfunction build_ensemble_simulation(observations, arch=CPU(); Nensemble=1)\n\n    observations isa Vector || (observations = [observations]) # Singleton batch\n    Nbatch = length(observations)\n\n    Q·µò, Q·µá, N¬≤, f, Œît, Lz, Nz, Hz, closure = extract_perfect_parameters(observations, Nensemble)\n\n    column_ensemble_size = ColumnEnsembleSize(Nz=Nz, ensemble=(Nensemble, Nbatch), Hz=Hz)\n    ensemble_grid = RectilinearGrid(arch, size = column_ensemble_size, topology = (Flat, Flat, Bounded), z = (-Lz, 0))\n\n    coriolis_ensemble = arch_array(arch, [FPlane(f=f[i, j]) for i = 1:Nensemble, j=1:Nbatch])\n    closure_ensemble = arch_array(arch, [deepcopy(closure) for i = 1:Nensemble, j=1:Nbatch])\n\n    Q·µò, Q·µá, N¬≤ = Tuple(arch_array(arch, p) for p in (Q·µò, Q·µá, N¬≤))\n\n    u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Q·µò))\n    b_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Q·µá), bottom = GradientBoundaryCondition(N¬≤))\n\n    tracers = first(observations).metadata.parameters.tracers\n\n    ensemble_model = HydrostaticFreeSurfaceModel(grid = ensemble_grid,\n                                                 tracers = tracers,\n                                                 buoyancy = BuoyancyTracer(),\n                                                 boundary_conditions = (; u=u_bcs, b=b_bcs),\n                                                 coriolis = coriolis_ensemble,\n                                                 closure = closure_ensemble)\n\n    ensemble_simulation = Simulation(ensemble_model; Œît=Œît, stop_time=first(observations).times[end])\n\n    return ensemble_simulation, closure\nend","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"The following illustrations uses a simple ensemble simulation with two ensemble members:","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"ensemble_simulation, closure‚òÖ = build_ensemble_simulation(observations; Nensemble=3)","category":"page"},{"location":"literated/intro_to_inverse_problems/#Free-parameters","page":"Intro to inverse problems","title":"Free parameters","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"We construct some prior distributions for our free parameters. We found that it often helps to constrain the prior distributions so that neither very high nor very low values for diffusivities can be drawn out of the distribution.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"priors = (convective_Œ∫z = lognormal(mean=0.3, std=0.05),\n          background_Œ∫z = lognormal(mean=2.5e-4, std=0.25e-4))\n\nfree_parameters = FreeParameters(priors)","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"We also take the opportunity to collect a named tuple of the optimal parameters","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"Œ∏‚òÖ = (convective_Œ∫z = closure‚òÖ.convective_Œ∫z,\n      background_Œ∫z = closure‚òÖ.background_Œ∫z)","category":"page"},{"location":"literated/intro_to_inverse_problems/#Visualizing-the-priors","page":"Intro to inverse problems","title":"Visualizing the priors","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"We visualize our prior distributions by plotting a huge number of samples:","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"using OceanTurbulenceParameterEstimation.Parameters: unconstrained_prior, transform_to_constrained\n\nNsamples = 50000000\n\nsample(prior) = [transform_to_constrained(prior, X) for X in rand(unconstrained_prior(prior), Nsamples)]\n\nconvective_Œ∫z_samples = sample(priors.convective_Œ∫z)\nbackground_Œ∫z_samples = sample(priors.background_Œ∫z)\n\nfig = Figure()\nax_top = Axis(fig[1, 1], xlabel = \"convective Œ∫·∂ª [m¬≤ s‚Åª¬π]\", ylabel = \"Density\")\ndensity!(ax_top, convective_Œ∫z_samples)\nxlims!(ax_top, 0, 10)\n\nax_bottom = Axis(fig[2, 1], xlabel = \"background Œ∫·∂ª [m¬≤ s‚Åª¬π]\", ylabel = \"Density\")\ndensity!(ax_bottom, background_Œ∫z_samples)\n\nsave(\"prior_visualization.svg\", fig)\nnothing # hide","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"(Image: )","category":"page"},{"location":"literated/intro_to_inverse_problems/#The-InverseProblem","page":"Intro to inverse problems","title":"The InverseProblem","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"We can construct the inverse problem y = G(Œ∏) + Œ∑. Here, y are the observations and G is the ensemble_model.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"calibration = InverseProblem(observations, ensemble_simulation, free_parameters)","category":"page"},{"location":"literated/intro_to_inverse_problems/#Using-InverseProblem-to-compute-forward_map","page":"Intro to inverse problems","title":"Using InverseProblem to compute forward_map","text":"","category":"section"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"As a sanity check we apply the forward_map on the calibration after we initialize all ensemble members with the true parameter values. We then confirm that the output of the forward_map matches the observations to machine precision.","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"Œ∏¬π = (convective_Œ∫z = 0.8 * Œ∏‚òÖ.convective_Œ∫z,\n      background_Œ∫z = 9.0 * Œ∏‚òÖ.background_Œ∫z)\n\nŒ∏¬≤ = (convective_Œ∫z = 2.0 * Œ∏‚òÖ.convective_Œ∫z,\n      background_Œ∫z = 0.1 * Œ∏‚òÖ.background_Œ∫z)\n\nŒ∏_ensemble = [Œ∏‚òÖ, Œ∏¬π, Œ∏¬≤]\n\nG = forward_map(calibration, Œ∏_ensemble)\ny = observation_map(calibration)","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"The forward_map output G is a two-dimensional matrix whose first dimension is the size of the state space and whose second dimension is the ensemble_size. Here, we ensure that first ensemble member of the mapped output, which was run with the \"true\" parameters, is identical to the mapped observations:","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"G[:, 1] ‚âà y","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"Visualizing forward model output","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"Next we visualize the discrepency between solutions generated by true and non-optimal parameter sets Œ∏¬π and Œ∏¬≤. Time-series data from the ensemble run is collected by calibration.time_series_collector:","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"time_series_collector = calibration.time_series_collector\ntimes = time_series_collector.times\n\n# Extract last save point and plot each solution component\nNt = length(times)\n\nb = time_series_collector.field_time_serieses.b[Nt]\nt = times[Nt]\nz = znodes(b)\n\n# The ensemble varies along the first, or `x`-dimension:\nb‚òÖ = interior(b)[1, 1, :]\nb¬π = interior(b)[2, 1, :]\nb¬≤ = interior(b)[3, 1, :]\n\nfig = Figure()\nax = Axis(fig[1, 1],\n          xlabel = \"Buoyancy [m s‚Åª¬≤]\",\n          ylabel = \"Depth [m]\")\n\nb‚òÖ_label = \"true b at t = \" * prettytime(t)\nb¬π_label = \"b with $Œ∏¬π\"\nb¬≤_label = \"b with $Œ∏¬≤\"\n\nlines!(ax, b‚òÖ, z; label=b‚òÖ_label, linewidth=2)\nlines!(ax, b¬π, z; label=b¬π_label, linewidth=2)\nlines!(ax, b¬≤, z; label=b¬≤_label, linewidth=2)\n\naxislegend(ax, position=:lt)\n\nsave(\"ensemble_simulation_demonstration.svg\", fig); nothing # hide","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"(Image: )","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"","category":"page"},{"location":"literated/intro_to_inverse_problems/","page":"Intro to inverse problems","title":"Intro to inverse problems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"library/outline/#Library-Outline","page":"Contents","title":"Library Outline","text":"","category":"section"},{"location":"library/outline/","page":"Contents","title":"Contents","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"library/internals/#Private-types-and-functions","page":"Private","title":"Private types and functions","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Documentation for OceanTurbulenceParameterEstimation.jl's internal interface.","category":"page"},{"location":"library/internals/#OceanTurbulenceParameterEstimation","page":"Private","title":"OceanTurbulenceParameterEstimation","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [OceanTurbulenceParameterEstimation]\nPublic = false\nPages   = [\"OceanTurbulenceParameterEstimation.jl\"]","category":"page"},{"location":"library/internals/#Transformations","page":"Private","title":"Transformations","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [OceanTurbulenceParameterEstimation.Transformations]\nPublic = false\nPages   = [\"Transformations.jl\"]","category":"page"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Transformations.compute_normalization-Tuple{ZScore{Nothing}, Any, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.Transformations.compute_normalization","text":"Compute ZScore on time- and space-transformed field time series data.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Transformations.compute_time_transformation-Tuple{Nothing, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.Transformations.compute_time_transformation","text":"compute_time_transformation(user_time_transformation, fts)\n\nCompute a time transformation for the field time series fts given user_time_transformation.\n\nBy default, if user_time_transformation isa nothing, then we include all time instances except the initial condition.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Observations","page":"Private","title":"Observations","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [OceanTurbulenceParameterEstimation.Observations]\nPublic = false","category":"page"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Observations.FieldTimeSeriesCollector-Tuple{Any, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.Observations.FieldTimeSeriesCollector","text":"FieldTimeSeriesCollector(collected_fields, times;\n                         architecture = Architectures.architecture(first(collected_fields)))\n\nReturn a FieldTimeSeriesCollector for fields of simulation. fields is a NamedTuple of AbstractFields that are to be collected.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Observations.column_ensemble_interior-Tuple{Vector{var\"#s84\"} where var\"#s84\"<:SyntheticObservations, Any, Any, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.Observations.column_ensemble_interior","text":"column_ensemble_interior(observations::Vector{<:SyntheticObservations},\n                         field_name, time_index, (Nensemble, Nbatch, Nz))\n\nReturn an Nensemble √ó Nbatch √ó Nz Array of (1, 1, Nz) field_name data, given Nbatch SyntheticObservations objects. The Nbatch √ó Nz data for field_name is copied Nensemble times to form a 3D Array.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Observations.observation_names-Tuple{Vector{var\"#s86\"} where var\"#s86\"<:SyntheticObservations}","page":"Private","title":"OceanTurbulenceParameterEstimation.Observations.observation_names","text":"observation_names(observations::Vector{<:SyntheticObservations})\n\nReturn a Set representing the union of all names in obs.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Ensemble-Simulations","page":"Private","title":"Ensemble Simulations","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [OceanTurbulenceParameterEstimation.EnsembleSimulations]\nPublic = false","category":"page"},{"location":"library/internals/#Parameters","page":"Private","title":"Parameters","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [OceanTurbulenceParameterEstimation.Parameters]\nPublic = false","category":"page"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Parameters.closure_with_parameters-Tuple{Any, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.Parameters.closure_with_parameters","text":"closure_with_parameters(closure, parameters)\n\nReturn a new object where for each (parameter_name, parameter_value) pair  in parameters, the value corresponding to the key in closure that matches parameter_name is replaced with parameter_value.\n\nExample\n\nCreate a placeholder Closure type that includes a parameter c and a sub-closure with two parameters: a and b. Then construct a closure with values a, b, c = 1, 2, 3.\n\njulia> struct Closure; subclosure; c end\n\njulia> struct ClosureSubModel; a; b end\n\njulia> sub_closure = ClosureSubModel(1, 2)\nClosureSubModel(1, 2)\n\njulia> closure = Closure(sub_closure, 3)\nClosure(ClosureSubModel(1, 2), 3)\n\nProviding closure_with_parameters with a named tuple of parameter names and values, and a recursive search in all types and subtypes within closure is done and whenever a parameter is found whose name exists in the named tuple we provided, its value is  then replaced with the value provided.\n\njulia> new_parameters = (a = 12, d = 7)\n(a = 12, d = 7)\n\njulia> using OceanTurbulenceParameterEstimation.Parameters: closure_with_parameters\n\njulia> closure_with_parameters(closure, new_parameters)\nClosure(ClosureSubModel(12, 2), 3)\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Parameters.construct_object-Tuple{Union{Number, AbstractArray}, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.Parameters.construct_object","text":"construct_object(specification_dict, parameters; name=nothing, type_parameter=nothing)\n\nconstruct_object(d::ParameterValue, parameters; name=nothing)\n\nReturn a composite type object whose properties are prescribed by the specification_dict dictionary. All parameter values are given the values in specification_dict unless they are included as a parameter name-value pair in the named tuple parameters, in which case the value in parameters is asigned.\n\nThe construct_object is recursively called upon every property that is included in specification_dict until a property with a numerical value is reached. The object's constructor name must be included in specification_dict under key :type.\n\nExample\n\njulia> using OceanTurbulenceParameterEstimation.Parameters: construct_object, dict_properties, closure_with_parameters\n\njulia> struct Closure; subclosure; c end\n\njulia> struct ClosureSubModel; a; b end\n\njulia> sub_closure = ClosureSubModel(1, 2)\nClosureSubModel(1, 2)\n\njulia> closure = Closure(sub_closure, 3)\nClosure(ClosureSubModel(1, 2), 3)\n\njulia> specification_dict = dict_properties(closure)\nDict{Symbol, Any} with 3 entries:\n  :type       => Closure\n  :c          => 3\n  :subclosure => Dict{Symbol, Any}(:a=>1, :b=>2, :type=>ClosureSubModel)\n\njulia> new_closure = construct_object(specification_dict, (a=2.1,))\nClosure(ClosureSubModel(2.1, 2), 3)\n  \njulia> another_new_closure = construct_object(specification_dict, (b=œÄ, c=2œÄ))\nClosure(ClosureSubModel(1, œÄ), 6.283185307179586)\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Parameters.dict_properties-Tuple{Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.Parameters.dict_properties","text":"dict_properties(object)\n\nReturn a dictionary with all properties of an object and their values, including the  object's type name. If any of the object's properties is not a numerical value but instead a composite type, then dict_properties is called recursively on that object's property returning a dictionary with all properties of that composite type. Recursion ends when properties of type ParameterValue are found.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Parameters.new_closure_ensemble-Tuple{AbstractArray, Any, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.Parameters.new_closure_ensemble","text":"new_closure_ensemble(closures, Œ∏, arch=CPU())\n\nReturn a new set of closures in which all closures that have free parameters are updated. Closures with free parameters are expected as AbstractArray of TurbulenceClosures, and this allows new_closure_ensemble to go through all closures in closures and only update the parameters for the any closure that is of type AbstractArray. The architecture (CPU() or GPU()) defines whethere Array or CuArray is returned.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Parameters.normal_to_scaled_logit_normal-Tuple{Any, Any, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.Parameters.normal_to_scaled_logit_normal","text":"Return a logit-normally distributed variate given the normally-distributed variate X.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Parameters.scaled_logit_normal_to_normal-Tuple{Any, Any, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.Parameters.scaled_logit_normal_to_normal","text":"Return a normally-distributed variate given the logit-normally distributed variate Y.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Parameters.transform_to_constrained-Tuple{Normal, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.Parameters.transform_to_constrained","text":"transform_to_constrained(Œ†, X)\n\nTransform an \"unconstrained\", normally-distributed variate X to \"constrained\" (physical) space via the map associated with the distribution Œ† of Y.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Parameters.transform_to_unconstrained-Tuple{Normal, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.Parameters.transform_to_unconstrained","text":"transform_to_unconstrained(Œ†, Y)\n\nTransform the \"constrained\" (physical) variate Y into it's unconstrained (normally-distributed) counterpart X through the forward map associated with Œ†.\n\nIf some mapping between Y and the normally-distributed X is defined via\n\nY = g(X)\n\nThen transform_to_unconstrained is the inverse X = g^-1(Y). The change of variables g(X) determines the distribution Œ† of Y.\n\nExample\n\nThe logarithm of a LogNormal(Œº, œÉ) distributed variate is normally-distributed, such that the forward trasform f  exp,\n\nY = exp(X)\n\nand the inverse trasnform is the natural logarithm f^-1  log,\n\nlog(Y) = X  ùí©(Œº œÉ)\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.Parameters.update_closure_ensemble_member!-Tuple{Any, Any, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.Parameters.update_closure_ensemble_member!","text":"update_closure_ensemble_member!(closures, p_ensemble, parameters)\n\nUse parameters to update the p_ensemble-th closure from and array of closures. The p_ensemble-th closure corresponds to ensemble member p_ensemble.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Inverse-Problems","page":"Private","title":"Inverse Problems","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [OceanTurbulenceParameterEstimation.InverseProblems]\nPublic = false","category":"page"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.InverseProblems.expand_parameters-Tuple{Any, Vector{T} where T}","page":"Private","title":"OceanTurbulenceParameterEstimation.InverseProblems.expand_parameters","text":"expand_parameters(ip, Œ∏)\n\nConvert Œ∏ to Vector{<:NamedTuple}, where the elements correspond to ip.free_parameters.\n\nŒ∏ may represent an ensemble of parameter sets via:\n\nŒ∏::Vector{<:Vector} (caution: parameters must be ordered correctly!)\nŒ∏::Matrix (caution: parameters must be ordered correctly!)\nŒ∏::Vector{<:NamedTuple} \n\nor a single parameter set if Œ∏::Vector{<:Number}.\n\nIf length(Œ∏) is less the the number of ensemble members in ip.simulation, the last parameter set is copied to fill the parameter set ensemble.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.InverseProblems.transform_time_series-Tuple{Any, Vector{T} where T}","page":"Private","title":"OceanTurbulenceParameterEstimation.InverseProblems.transform_time_series","text":"transform_time_series(map, batched_observations::Vector)\n\nConcatenate the output of transform_time_series of each observation in batched_observations.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.InverseProblems.transform_time_series-Tuple{ConcatenatedOutputMap, SyntheticObservations}","page":"Private","title":"OceanTurbulenceParameterEstimation.InverseProblems.transform_time_series","text":"transform_time_series(::ConcatenatedOutputMap, observation::SyntheticObservations)\n\nTransforms, normalizes, and concatenates data for field time series in observation.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.InverseProblems.transpose_model_output-Tuple{Oceananigans.Grids.AbstractGrid{var\"#s1453\", var\"#s1452\", var\"#s1451\", var\"#s1450\", Arch} where {var\"#s1453\"<:AbstractFloat, var\"#s1452\"<:Oceananigans.Grids.Flat, var\"#s1451\"<:Oceananigans.Grids.Flat, var\"#s1450\"<:Oceananigans.Grids.Bounded, Arch}, Any, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.InverseProblems.transpose_model_output","text":"transpose_model_output(time_series_collector, observations)\n\nTranspose a NamedTuple of 4D FieldTimeSeries model output collected by time_series_collector into a Vector of SyntheticObservations for each member of the observation batch.\n\nReturn a 1-vector in the case of singleton observations.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#EnsembleKalmanInversions","page":"Private","title":"EnsembleKalmanInversions","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [OceanTurbulenceParameterEstimation.EnsembleKalmanInversions]\nPublic = false","category":"page"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.IterationSummary","page":"Private","title":"OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.IterationSummary","text":"IterationSummary(eki, X, forward_map_output=nothing)\n\nReturn the summary for ensemble Kalman inversion eki with unconstrained parameters X and forward_map_output.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.column_has_nan-Tuple{Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.column_has_nan","text":"Return a BitVector indicating which particles are NaN.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.resample!-Tuple{Resampler, Any, Any, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.resample!","text":"resample!(resampler::Resampler, Œ∏, G, eki)\n\nResamples the parameters Œ∏ of the eki process based on the number of NaN values inside the forward map output G.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.sample-NTuple{4, Any}","page":"Private","title":"OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.sample","text":"sample(eki, Œ∏, G, Nsample)\n\nGenerate Nsample new particles sampled from a multivariate Normal distribution parameterized  by the ensemble mean and covariance computed based on the NŒ∏ √ó Nensemble ensemble  array Œ∏, under the condition that all Nsample particles produce successful forward map outputs (don't include NaNs).\n\nG (size(G) =  Noutput √ó Nensemble) is the forward map output produced by Œ∏.\n\nReturns NŒ∏ √ó Nsample parameter Array and Noutput √ó Nsample forward map output Array.\n\n\n\n\n\n","category":"method"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"EditURL = \"https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/blob/main/examples/perfect_baroclinic_adjustment_calibration.jl\"","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Perfect-baroclinic-adjustment-calibration-with-Ensemble-Kalman-Inversion","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"This example showcases a \"perfect model calibration\" of the two-dimensional baroclinic adjustement problem (depth-latitude) with eddies parametrized using Gent-McWilliams‚ÄìRedi isoneutral diffusion closure. We use output for buoyancy (b) and a passive-tracer concentration (c) to calibrate the parametrization.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Install-dependencies","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Install dependencies","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"using Pkg\npkg\"add Oceananigans, Distributions, CairoMakie, OceanTurbulenceParameterEstimation\"","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"First we load few things","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"using OceanTurbulenceParameterEstimation\n\nusing Oceananigans\nusing Oceananigans.Units\nusing Oceananigans.TurbulenceClosures: FluxTapering\nusing Oceananigans.Models.HydrostaticFreeSurfaceModels: SliceEnsembleSize\nusing Distributions\nusing Printf\nusing LinearAlgebra: norm","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Set-up-the-problem-and-generate-observations","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Set up the problem and generate observations","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"Define the  \"true\" skew and symmetric diffusivity coefficients. These are the parameter values that we use to generate the data. Then, we'll see if the EKI calibration can recover these values.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"Œ∫_skew = 1000.0       # [m¬≤ s‚Åª¬π] skew diffusivity\nŒ∫_symmetric = 900.0   # [m¬≤ s‚Åª¬π] symmetric diffusivity\nnothing # hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"We gather the \"true\" parameters in a named tuple Œ∏_*:","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"Œ∏‚òÖ = (Œ∫_skew = Œ∫_skew, Œ∫_symmetric = Œ∫_symmetric)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"The experiment name and where the synthetic observations will be saved.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"experiment_name = \"baroclinic_adjustment\"\ndata_path = experiment_name * \".jld2\"","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"The domain, number of grid points, and other parameters.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"architecture = CPU()      # CPU or GPU?\nLy = 1000kilometers       # north-south extent [m]\nLz = 1kilometers          # depth [m]\nNy = 64                   # grid points in north-south direction\nNz = 16                   # grid points in the vertical\nŒît = 10minute             # time-step\nstop_time = 1days         # length of run\nsave_interval = 0.25days  # save observation every so often\n\nforce_generate_observations = false\nnothing # hide\n\nanisotropic_diffusivity = AnisotropicDiffusivity(Œ∫h=100, Œ∫z=1e-2)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"The isopycnal skew-symmetric diffusivity closure.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"gerdes_koberle_willebrand_tapering = FluxTapering(1e-2)\ngent_mcwilliams_diffusivity = IsopycnalSkewSymmetricDiffusivity(Œ∫_skew = Œ∫_skew,\n                                                                Œ∫_symmetric = Œ∫_symmetric,\n                                                                slope_limiter = gerdes_koberle_willebrand_tapering)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Generate-synthetic-observations","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Generate synthetic observations","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"if force_generate_observations || !(isfile(data_path))\n    grid = RectilinearGrid(architecture,\n                           topology = (Flat, Bounded, Bounded),\n                           size = (Ny, Nz),\n                           y = (-Ly/2, Ly/2),\n                           z = (-Lz, 0),\n                           halo = (3, 3))\n\n    closures = (gent_mcwilliams_diffusivity, anisotropic_diffusivity)\n\n    model = HydrostaticFreeSurfaceModel(grid = grid,\n                                        tracers = (:b, :c),\n                                        buoyancy = BuoyancyTracer(),\n                                        coriolis = BetaPlane(latitude=-45),\n                                        closure = closures,\n                                        free_surface = ImplicitFreeSurface())\n\n    @info \"Built $model.\"\n\n    ##### Initial conditions of an unstable buoyancy front\n\n    \"\"\"\n    Linear ramp from 0 to 1 between -Œîy/2 and +Œîy/2.\n\n    For example:\n\n    y < y‚ÇÄ           => ramp = 0\n    y‚ÇÄ < y < y‚ÇÄ + Œîy => ramp = y / Œîy\n    y > y‚ÇÄ + Œîy      => ramp = 1\n    \"\"\"\n    ramp(y, Œîy) = min(max(0, y/Œîy + 1/2), 1)\n\n    N¬≤ = 4e-6             # [s‚Åª¬≤] buoyancy frequency / stratification\n    M¬≤ = 8e-8             # [s‚Åª¬≤] horizontal buoyancy gradient\n\n    Œîy = 50kilometers     # horizontal extent of the font\n\n    Œîc_y = 2Œîy            # horizontal extent of initial tracer concentration\n    Œîc_z = 50             # [m] vertical extent of initial tracer concentration\n\n    Œîb = Œîy * M¬≤          # inital buoyancy jump\n\n    b·µ¢(x, y, z) = N¬≤ * z + Œîb * ramp(y, Œîy)\n    c·µ¢(x, y, z) = exp(-y^2 / 2Œîc_y^2) * exp(-(z + Lz/2)^2 / (2Œîc_z^2))\n\n    set!(model, b=b·µ¢, c=c·µ¢)\n\n    simulation = Simulation(model, Œît=Œît, stop_time=stop_time)\n\n    simulation.output_writers[:fields] = JLD2OutputWriter(model, merge(model.velocities, model.tracers),\n                                                          schedule = TimeInterval(save_interval),\n                                                          prefix = experiment_name,\n                                                          array_type = Array{Float64},\n                                                          field_slicer = nothing,\n                                                          force = true)\n\n    run!(simulation)\nend","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Load-truth-data-as-observations","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Load truth data as observations","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"We use here the Transformation functionality to slice up the observation data a bit. In particular, we choose to exclude the 3 grid points on either side of the y dimension, and 3 grid points from the bottom of the domain. Also, we only use the last 3 snapshots of the observations.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"We use SpaceIndices and TimeIndices to denote which space-time indices we would like to keep in observations.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"transformation = Transformation(space=SpaceIndices(y=4:Ny-3, z=4:Nz), time=TimeIndices(3:5), normalization=ZScore())\nobservations = SyntheticObservations(data_path; field_names=(:b, :c), transformation)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Calibration-with-Ensemble-Kalman-Inversion","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Calibration with Ensemble Kalman Inversion","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Ensemble-model","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Ensemble model","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"First we set up an ensemble model,","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"ensemble_size = 20\n\nslice_ensemble_size = SliceEnsembleSize(size=(Ny, Nz), ensemble=ensemble_size)\n\n@show ensemble_grid = RectilinearGrid(architecture,\n                                      size=slice_ensemble_size,\n                                      topology = (Flat, Bounded, Bounded),\n                                      y = (-Ly/2, Ly/2),\n                                      z = (-Lz, 0),\n                                      halo=(3, 3))\n\ngm_ensemble = [deepcopy(gent_mcwilliams_diffusivity) for i = 1:ensemble_size]\nclosures = (gm_ensemble, anisotropic_diffusivity)\n\n@show ensemble_model = HydrostaticFreeSurfaceModel(grid = ensemble_grid,\n                                                   tracers = (:b, :c),\n                                                   buoyancy = BuoyancyTracer(),\n                                                   coriolis = BetaPlane(latitude=-45),\n                                                   closure = closures,\n                                                   free_surface = ImplicitFreeSurface())","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"and then we create an ensemble simulation:","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"ensemble_simulation = Simulation(ensemble_model; Œît, stop_time)\n\nensemble_simulation","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Free-parameters","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Free parameters","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"We construct some prior distributions for our free parameters. We found that it often helps to constrain the prior distributions so that neither very high nor very low values for diffusivities can be drawn out of the distribution.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"priors = (Œ∫_skew = ScaledLogitNormal(bounds=(400.0, 1300.0)),\n          Œ∫_symmetric = ScaledLogitNormal(bounds=(700.0, 1700.0)))\n\nfree_parameters = FreeParameters(priors)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"To visualize the prior distributions we randomly sample out values from then and plot the p.d.f.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"using CairoMakie\nusing OceanTurbulenceParameterEstimation.Parameters: unconstrained_prior, transform_to_constrained\n\nsamples(prior) = [transform_to_constrained(prior, x) for x in rand(unconstrained_prior(prior), 10000000)]\n\nsamples_Œ∫_skew = samples(priors.Œ∫_skew)\nsamples_Œ∫_symmetric = samples(priors.Œ∫_symmetric)\n\nfig = Figure()\nax = Axis(fig[1, 1], xlabel = \"Diffusivities [m¬≤ s‚Åª¬π]\", ylabel = \"PDF\")\ndensities = []\npush!(densities, density!(ax, samples_Œ∫_skew))\npush!(densities, density!(ax, samples_Œ∫_symmetric))\nLegend(fig[1, 2], densities, [\"Œ∫_skew\", \"Œ∫_symmetric\"], position = :lb)\n\nsave(\"visualize_prior_diffusivities_baroclinic_adjustment.svg\", fig); nothing # hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#The-inverse-problem","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"The inverse problem","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"We can construct the inverse problem y = G(Œ∏) + Œ∑. Here, y are the observations and G is the ensemble_model.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"calibration = InverseProblem(observations, ensemble_simulation, free_parameters)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/#Assert-that-G(Œ∏_*)-y","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Assert that G(Œ∏_*)  y","text":"","category":"section"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"As a sanity check we apply the forward_map on the calibration after we initialize all ensemble members with the true parameter values. We then confirm that the output of the forward_map matches the observations to machine precision.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"G = forward_map(calibration, Œ∏‚òÖ)\ny = observation_map(calibration)\nnothing #hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"The forward_map output G is a two-dimensional matrix whose first dimension is the size of the state space. Here, after the transformation we applied to the observations, we have that the state space size is 2 times (N_y - 6) times (N_z - 3) times 3; the 2 comes from the two tracers we used as observations and the 3 comes from only using the last three snapshots of the observations. The second dimension of the forward_map output is the ensemble_size.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"@show size(G) == (2 * (Ny-6) * (Nz-3) * 3, ensemble_size)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"Since above we computed G using the true parameters Œ∏_*, all columns of the forward map output should be the same as the observations:","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"mean(G, dims=2) ‚âà y","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"Next, we construct an EnsembleKalmanInversion (EKI) object,","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"eki = EnsembleKalmanInversion(calibration; noise_covariance = 1e-2)","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"and perform few iterations to see if we can converge to the true parameter values.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"params = iterate!(eki; iterations = 5)\n\n@show params","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"Last, we visualize few metrics regarding how the EKI calibration went about.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"Œ∏ÃÖ(iteration) = [eki.iteration_summaries[iteration].ensemble_mean...]\nvarŒ∏(iteration) = eki.iteration_summaries[iteration].ensemble_var\n\nweight_distances = [norm(Œ∏ÃÖ(iter) - [Œ∏‚òÖ[1], Œ∏‚òÖ[2]]) for iter in 1:eki.iteration]\noutput_distances = [norm(forward_map(calibration, Œ∏ÃÖ(iter))[:, 1] - y) for iter in 1:eki.iteration]\nensemble_variances = [varŒ∏(iter) for iter in 1:eki.iteration]\n\nf = Figure()\nlines(f[1, 1], 1:eki.iteration, weight_distances, color = :red, linewidth = 2,\n      axis = (title = \"Parameter distance\",\n              xlabel = \"Iteration\",\n              ylabel=\"|Œ∏ÃÖ‚Çô - Œ∏‚ãÜ|\",\n              yscale = log10))\nlines(f[1, 2], 1:eki.iteration, output_distances, color = :blue, linewidth = 2,\n      axis = (title = \"Output distance\",\n              xlabel = \"Iteration\",\n              ylabel=\"|G(Œ∏ÃÖ‚Çô) - y|\",\n              yscale = log10))\nax3 = Axis(f[2, 1:2], title = \"Parameter convergence\",\n           xlabel = \"Iteration\",\n           ylabel = \"Ensemble variance\",\n           yscale = log10)\n\nfor (i, pname) in enumerate(free_parameters.names)\n    ev = getindex.(ensemble_variances, i)\n    lines!(ax3, 1:eki.iteration, ev / ev[1], label = String(pname), linewidth = 2)\nend\n\naxislegend(ax3, position = :rt)\nsave(\"summary_baroclinic_adjustment.svg\", f); nothing #hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"And also we plot the the distributions of the various model ensembles for few EKI iterations to see if and how well they converge to the true diffusivity values.","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"f = Figure()\n\naxtop = Axis(f[1, 1])\n\naxmain = Axis(f[2, 1],\n              xlabel = \"Œ∫_skew [m¬≤ s‚Åª¬π]\",\n              ylabel = \"Œ∫_symmetric [m¬≤ s‚Åª¬π]\")\n\naxright = Axis(f[2, 2])\nscatters = []\nlabels = String[]\n\nfor iteration in [0, 1, 2, 5]\n    # Make parameter matrix\n    parameters = eki.iteration_summaries[iteration].parameters\n    Nensemble = length(parameters)\n    Nparameters = length(first(parameters))\n    parameter_ensemble_matrix = [parameters[i][j] for i=1:Nensemble, j=1:Nparameters]\n\n    label = iteration == 0 ? \"Initial ensemble\" : \"Iteration $iteration\"\n    push!(labels, label)\n    push!(scatters, scatter!(axmain, parameter_ensemble_matrix))\n    density!(axtop, parameter_ensemble_matrix[:, 1])\n    density!(axright, parameter_ensemble_matrix[:, 2], direction = :y)\nend\n\nvlines!(axmain, [Œ∫_skew], color = :red)\nvlines!(axtop, [Œ∫_skew], color = :red)\n\nhlines!(axmain, [Œ∫_symmetric], color = :red)\nhlines!(axright, [Œ∫_symmetric], color = :red)\n\ncolsize!(f.layout, 1, Fixed(300))\ncolsize!(f.layout, 2, Fixed(200))\n\nrowsize!(f.layout, 1, Fixed(200))\nrowsize!(f.layout, 2, Fixed(300))\n\nLegend(f[1, 2], scatters, labels, position = :lb)\n\nhidedecorations!(axtop, grid = false)\nhidedecorations!(axright, grid = false)\n\nxlims!(axmain, 350, 1350)\nxlims!(axtop, 350, 1350)\nylims!(axmain, 650, 1750)\nylims!(axright, 650, 1750)\nxlims!(axright, 0, 0.025)\nylims!(axtop, 0, 0.025)\n\nsave(\"distributions_baroclinic_adjustment.svg\", f); nothing #hide","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"","category":"page"},{"location":"literated/perfect_baroclinic_adjustment_calibration/","page":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","title":"Perfect baroclinic adjustment calibration with Ensemble Kalman Inversion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"library/function_index/#main-index","page":"Function index","title":"Index","text":"","category":"section"},{"location":"library/function_index/","page":"Function index","title":"Function index","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"EditURL = \"https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/blob/main/examples/intro_to_observations.jl\"","category":"page"},{"location":"literated/intro_to_observations/#Intro-to-observations","page":"Intro to observations","title":"Intro to observations","text":"","category":"section"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"This example demonstrates the features of SyntheticObservations when constructed from  \"synthetic observations\" generated by an Oceananigans Simulation.","category":"page"},{"location":"literated/intro_to_observations/#Install-dependencies","page":"Intro to observations","title":"Install dependencies","text":"","category":"section"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"using Pkg\npkg\"add OceanTurbulenceParameterEstimation, Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"First we load few things","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"using OceanTurbulenceParameterEstimation\nusing Oceananigans\nusing Oceananigans.Units\nusing Oceananigans.TurbulenceClosures: ConvectiveAdjustmentVerticalDiffusivity\nusing CairoMakie","category":"page"},{"location":"literated/intro_to_observations/#Generating-synthetic-observations","page":"Intro to observations","title":"Generating synthetic observations","text":"","category":"section"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"We define a utility function for constructing synthetic observations,","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"default_closure = ConvectiveAdjustmentVerticalDiffusivity(; convective_Œ∫z = 1.0,\n                                                            convective_ŒΩz = 0.9,\n                                                            background_Œ∫z = 1e-4,\n                                                            background_ŒΩz = 1e-5)\n\nfunction generate_synthetic_observations(name = \"convective_adjustment\"; Nz = 32, Lz = 64,\n                                         Q·µá = +1e-8, Q·µò = -1e-5, f‚ÇÄ = 1e-4, N¬≤ = 1e-6,\n                                         Œît = 10.0, stop_time = 12hours, overwrite=false,\n                                         tracers = :b, closure = default_closure)\n\n    data_path = name * \".jld2\"\n\n    if isfile(data_path)\n        @warn(\"Using existing data at $data_path. \" *\n              \"Please delete this file if you wish to generate new data.\")\n\n        return data_path\n    end\n\n    grid = RectilinearGrid(size=Nz, z=(-Lz, 0), topology=(Flat, Flat, Bounded))\n    u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Q·µò))\n    b_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Q·µá), bottom = GradientBoundaryCondition(N¬≤))\n\n    model = HydrostaticFreeSurfaceModel(; grid, tracers, closure,\n                                          buoyancy = BuoyancyTracer(),\n                                          boundary_conditions = (u=u_bcs, b=b_bcs),\n                                          coriolis = FPlane(f=f‚ÇÄ))\n\n    set!(model, b = (x, y, z) -> N¬≤ * z)\n    simulation = Simulation(model; Œît, stop_time)\n    init_with_parameters(file, model) = file[\"parameters\"] = (; Q·µá, Q·µò, Œît, N¬≤, tracers=keys(model.tracers))\n\n    simulation.output_writers[:fields] = JLD2OutputWriter(model, merge(model.velocities, model.tracers),\n                                                          schedule = TimeInterval(stop_time/3),\n                                                          prefix = name,\n                                                          array_type = Array{Float64},\n                                                          field_slicer = nothing,\n                                                          init = init_with_parameters,\n                                                          force = true)\n\n    run!(simulation)\n\n    return data_path\nend","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"and invoke it:","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"data_path = generate_synthetic_observations()","category":"page"},{"location":"literated/intro_to_observations/#Specifying-observations","page":"Intro to observations","title":"Specifying observations","text":"","category":"section"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"When synthetic observations are constructed from simulation data, we can select","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"The fields to include via field_names\nWhich data in the time-series to include via the times keyword. This can be used to change the initial condition for a calibration run.","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"For example, to build observations with a single field we write,","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"single_field_observations = SyntheticObservations(data_path, field_names=:b, transformation=ZScore())","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"To build observations with two fields we write","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"two_field_observations = SyntheticObservations(data_path, field_names=(:u, :b), transformation=ZScore())","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"And to build observations with specified times we write","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"times = single_field_observations.times[2:end]\nspecified_times_observations = SyntheticObservations(data_path, field_names=(:u, :b), transformation=ZScore(), times=times)","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"Notice that in the last case, specified_times_observations.times is missing 0.0.","category":"page"},{"location":"literated/intro_to_observations/#Visualizing-observations","page":"Intro to observations","title":"Visualizing observations","text":"","category":"section"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"For this we include the initial condition and v velocity component,","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"observations = SyntheticObservations(data_path, field_names=(:u, :v, :b), transformation=ZScore())\n\nfig = Figure()\n\nax_b = Axis(fig[1, 1], xlabel = \"Buoyancy [m s‚Åª¬≤]\", ylabel = \"z [m]\")\nax_u = Axis(fig[1, 2], xlabel = \"Velocities [m s‚Åª¬π]\", ylabel = \"z [m]\")\n\nz = znodes(Center, observations.grid)\n\ncolorcycle = [:black, :red, :blue, :orange, :pink]\n\nfor i = 1:length(observations.times)\n    b_ = observations.field_time_serieses.b[i]\n    u_ = observations.field_time_serieses.u[i]\n    v_ = observations.field_time_serieses.v[i]\n    t_ = observations.times[i]\n\n    label = \"t = \" * prettytime(t_)\n    u_label = i == 1 ? \"u, \" * label : label\n    v_label = i == 1 ? \"v, \" * label : label\n\n    lines!(ax_b, 1e4 * interior(b_)[1, 1, :], z; label, color=colorcycle[i]) # convert units from m s‚Åª¬≤ to 10‚Åª‚Å¥ m s‚Åª¬≤\n    lines!(ax_u, interior(u_)[1, 1, :], z; linestyle=:solid, color=colorcycle[i], label=u_label)\n    lines!(ax_u, interior(v_)[1, 1, :], z; linestyle=:dash, color=colorcycle[i], label=v_label)\nend\n\naxislegend(ax_b, position=:rb)\naxislegend(ax_u, position=:lb, merge=true)\n\nsave(\"intro_to_observations.svg\", fig)","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"(Image: )","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"Hint: if using a REPL or notebook, try using Pkg; Pkg.add(\"ElectronDisplay\"); using ElectronDisplay; display(fig) To see the figure in a window.","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"","category":"page"},{"location":"literated/intro_to_observations/","page":"Intro to observations","title":"Intro to observations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"EditURL = \"https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/blob/main/examples/lesbrary_catke_calibration.jl\"","category":"page"},{"location":"literated/lesbrary_catke_calibration/#CAKTE-calibration-with-Ensemble-Kalman-Inversion-using-LESbrary-data","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"","category":"section"},{"location":"literated/lesbrary_catke_calibration/#Install-dependencies","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"Install dependencies","text":"","category":"section"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"using Pkg\npkg\"add OceanTurbulenceParameterEstimation, Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"using Oceananigans\nusing Oceananigans.Units\nusing OceanTurbulenceParameterEstimation\nusing LinearAlgebra, CairoMakie, DataDeps\n\nusing Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities:\n    CATKEVerticalDiffusivity, MixingLength","category":"page"},{"location":"literated/lesbrary_catke_calibration/#Using-LESbrary-data","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"Using LESbrary data","text":"","category":"section"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"OceanTurbulenceParameterEstimation.jl provides paths to synthetic observations derived from high-fidelity large eddy simulations. In this example, we illustrate calibration of a turbulence parameterization to one of these simulations:","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"data_path = datadep\"two_day_suite_4m/strong_wind_instantaneous_statistics.jld2\"\ntimes = [2hours, 6hours, 12hours]\nfield_names = (:b, :u, :v, :e)\n\n# Use a special transformation that emphasizes buoyancy and de-emphasizes TKE\ntransformation = (b = ZScore(),\n                 u = ZScore(),\n                 v = ZScore(),\n                 e = RescaledZScore(0.1))\n\nobservations = SyntheticObservations(data_path; field_names, times, transformation)","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"Let's take a look at the observations. We define a few plotting utilities along the way to use later in the example:","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"colorcycle = [:black, :red, :darkblue, :orange, :pink1, :seagreen, :magenta2]\nmarkercycle = [:rect, :utriangle, :star5, :circle, :cross, :+, :pentagon]\n\nfunction make_figure_axes()\n    fig = Figure(resolution=(1200, 400))\n    ax_b = Axis(fig[1, 1], xlabel = \"Buoyancy \\n[cm s‚Åª¬≤]\", ylabel = \"z [m]\")\n    ax_u = Axis(fig[1, 2], xlabel = \"x-velocity, u \\n[cm s‚Åª¬π]\")\n    ax_v = Axis(fig[1, 3], xlabel = \"y-velocity, v \\n[cm s‚Åª¬π]\")\n    ax_e = Axis(fig[1, 4], xlabel = \"Turbulent kinetic energy \\n[cm¬≤ s‚Åª¬≤]\")\n    return fig, (ax_b, ax_u, ax_v, ax_e)\nend\n\nfunction plot_fields!(axs, b, u, v, e, label, color)\n    z = znodes(Center, b.grid)\n    # Note unit conversions below, eg m s‚Åª¬≤ -> cm s‚Åª¬≤:\n    lines!(axs[1], 1e2 * interior(b)[1, 1, :], z; color, label)\n    lines!(axs[2], 1e2 * interior(u)[1, 1, :], z; color, label)\n    lines!(axs[3], 1e2 * interior(v)[1, 1, :], z; color, label)\n    lines!(axs[4], 1e4 * interior(e)[1, 1, :], z; color, label)\n    return nothing\nend","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"And then plot the evolution of the observed fields,","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"fig, axs = make_figure_axes()\n\nfor (i, t) in enumerate(times)\n    fields = map(name -> observations.field_time_serieses[name][i], field_names)\n    plot_fields!(axs, fields..., \"t = \" * prettytime(t), colorcycle[i])\nend\n\n[axislegend(ax, position=:rb, merge=true, fontsize=10) for ax in axs]\n\nsave(\"lesbrary_synthetic_observations.svg\", fig); nothing # hide","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"(Image: )","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"Behold, boundary layer turbulence!","category":"page"},{"location":"literated/lesbrary_catke_calibration/#Calibration","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"Calibration","text":"","category":"section"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"Next, we build a simulation of an ensemble of column models to calibrate CATKE using Ensemble Kalman Inversion. We configure CATKE without convective adjustment and with constant (rather than Richardson-number-dependent) diffusivity parameters.","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"catke_mixing_length = MixingLength(C·¥∑c ≥=0.0, C·¥∑u ≥=0.0, C·¥∑e ≥=0.0)\ncatke = CATKEVerticalDiffusivity(mixing_length=catke_mixing_length)\n\nsimulation = ensemble_column_model_simulation(observations;\n                                              Nensemble = 20,\n                                              architecture = CPU(),\n                                              tracers = (:b, :e),\n                                              closure = catke)","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"The simulation is initialized with neutral boundary conditions and a default time-step, which we modify for our particular problem:","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"Q·µò = simulation.model.velocities.u.boundary_conditions.top.condition\nQ·µá = simulation.model.tracers.b.boundary_conditions.top.condition\nN¬≤ = simulation.model.tracers.b.boundary_conditions.bottom.condition\n\nsimulation.Œît = 10.0\n\nQ·µò .= observations.metadata.parameters.momentum_flux\nQ·µá .= observations.metadata.parameters.buoyancy_flux\nN¬≤ .= observations.metadata.parameters.N¬≤_deep","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"We identify a subset of the CATKE parameters to calibrate by specifying parameter names and prior distributions:","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"priors = (C·¥∞   = lognormal(mean=0.02, std=0.005),\n          C·µÇu‚òÖ = lognormal(mean=1.5,  std=0.25),\n          C·¥∏·µá  = lognormal(mean=0.01, std=0.005),\n          C·¥∑u‚Åª = ScaledLogitNormal(bounds=(0, 4)),\n          C·¥∑c‚Åª = ScaledLogitNormal(bounds=(0, 1)),\n          C·¥∑e‚Åª = ScaledLogitNormal(bounds=(0, 3)))\n\nfree_parameters = FreeParameters(priors)","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"TODO: explain the meaning of each parameter The prior information comes from experience, prior calibration runs, and educated guesses.","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"calibration = InverseProblem(observations, simulation, free_parameters)","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"Next, we calibrate, using a relatively large noise to reflect our uncertainty about how close the observations and model can really get,","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"eki = EnsembleKalmanInversion(calibration;\n                              noise_covariance = 1e-2,\n                              resampler = Resampler(acceptable_failure_fraction=0.1))\n\niterate!(eki; iterations = 5)","category":"page"},{"location":"literated/lesbrary_catke_calibration/#Results","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"Results","text":"","category":"section"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"To analyze the reuslts, we build a new simulation with just one ensemble member to evaluate pasome utilities for analyzing the results:","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"Nt = length(observations.times)\nNiter = length(eki.iteration_summaries) - 1\nmodeled_time_serieses = calibration.time_series_collector.field_time_serieses\nobserved = map(name -> observations.field_time_serieses[name][Nt], field_names)\nmodeled = map(name -> modeled_time_serieses[name][Nt], field_names)\n\nfunction compare_model_observations(model_label=\"modeled\")\n    fig, axs = make_figure_axes()\n    plot_fields!(axs, observed..., \"observed at t = \" * prettytime(times[end]), :black)\n    plot_fields!(axs, modeled..., model_label, :blue)\n    [axislegend(ax, position=:rb, merge=true, fontsize=10) for ax in axs]\n    return fig\nend","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"Now we execute forward runs for the initial ensemble mean,","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"initial_parameters = eki.iteration_summaries[0].ensemble_mean\nforward_run!(calibration, initial_parameters)\nfig = compare_model_observations(\"modeled after 0 iterations\")\n\nsave(\"model_observation_comparison_iteration_0.svg\", fig); nothing # hide","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"(Image: )","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"and the final ensemble mean, representing our \"best\" parameter set,","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"best_parameters = eki.iteration_summaries[end].ensemble_mean\nforward_run!(calibration, best_parameters)\nfig = compare_model_observations(\"modeled after $Niter iterations\")\n\nsave(\"model_observation_comparison_final_iteration.svg\", fig); nothing # hide","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"(Image: )","category":"page"},{"location":"literated/lesbrary_catke_calibration/#Parameter-evolution","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"Parameter evolution","text":"","category":"section"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"To understand how results changed over the EKI iterations, we look at the evoluation of the ensemble means,","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"ensemble_means = NamedTuple(n => map(summary -> summary.ensemble_mean[n], eki.iteration_summaries)\n                            for n in calibration.free_parameters.names)\n\nfig = Figure()\nax = Axis(fig[1, 1], xlabel = \"Ensemble Kalman iteration\", ylabel = \"Parameter value\")\n\nfor (i, name) in enumerate(calibration.free_parameters.names)\n    label = string(name)\n    marker = markercycle[i]\n    color = colorcycle[i]\n    scatterlines!(ax, 0:Niter, parent(ensemble_means[name]); marker, color, label)\nend\n\naxislegend(ax, position=:rb)\n\nsave(\"lesbrary_catke_parameter_evolution.svg\", fig); nothing # hide","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"(Image: )","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"","category":"page"},{"location":"literated/lesbrary_catke_calibration/","page":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","title":"CAKTE calibration with Ensemble Kalman Inversion using LESbrary data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"EditURL = \"https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/blob/main/examples/exploring_priors.jl\"","category":"page"},{"location":"literated/exploring_priors/#Specifying-and-fine-tuning-prior-distributions","page":"Exploring Prior distributions","title":"Specifying and fine-tuning prior distributions","text":"","category":"section"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"This example shows how to specify priors in OceanTurbulenceParameterEstimation and illustrates some of their properties.","category":"page"},{"location":"literated/exploring_priors/#Install-dependencies","page":"Exploring Prior distributions","title":"Install dependencies","text":"","category":"section"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"using Pkg\npkg\"add OceanTurbulenceParameterEstimation, Oceananigans, Distributions, CairoMakie\"","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"Then we import packages","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"using OceanTurbulenceParameterEstimation\nusing CairoMakie\nusing Distributions","category":"page"},{"location":"literated/exploring_priors/#What's-a-prior?","page":"Exploring Prior distributions","title":"What's a prior?","text":"","category":"section"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"A \"prior\" is a probability distribution for an known parameter that represents \"prior knowledge\" of the problem at hand, before we generate new knowledge with a new model-data comparison via ensemble Kalman inversion (EKI).","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"In the (EKI) context, a prior distribution determines (i) the initial distribution of parameter values in the ensemble and (ii) the mapping between physical space where constraints on parameter values are applied, and the \"unconstrained\" space in which the EKI dynamics evolve (and where parameters are assumed normally-distributed).","category":"page"},{"location":"literated/exploring_priors/#Prior-flavors","page":"Exploring Prior distributions","title":"Prior flavors","text":"","category":"section"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"OceanTurbulenceParameterEstimation supports three types of prior distributions. The normal prior distribution is provided by Distributions.jl,","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"normal_prior = Normal(0.1, 0.1)","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"For LogNormal priors, we provide a special constructor that takes the mean and standard deviation std of the prior distribution in constrained space:","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"lognormal_prior = lognormal(mean=0.1, std=0.1)","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"lognormal calculates Œº and œÉ for Distributions.Lognormal(Œº, œÉ). Parameters with a Lognormal prior distribution are strictly positive. Finally, the \"scaled\" logit-normal prior,","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"logitnormal_prior = ScaledLogitNormal(bounds=(0, 0.2))","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"can be used to provide strict upper and lower bounds for parameter values.","category":"page"},{"location":"literated/exploring_priors/#Samples","page":"Exploring Prior distributions","title":"Samples","text":"","category":"section"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"Sampling the distributions reveals their properties. We define a function to use later, too.","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"function visualize_priors(priors; samples = 10^6)\n    fig = Figure()\n    ax = Axis(fig[1, 1:9], xlabel=\"Random samples of priors\", ylabel=\"Density\")\n\n    for (prior, name) in zip(values(priors), keys(priors))\n        density!(ax, rand(prior, samples), label=replace(string(name), \"_\" => \" \"))\n    end\n\n    axislegend(ax)\n\n    return fig, ax\nend\n\nfig, ax = visualize_priors(Dict(\"Normal\" => normal_prior,\n                                \"Log normal\" => lognormal_prior,\n                                \"Scaled logit-normal\" => logitnormal_prior))\n\nxlims!(ax, -0.5, 1.5)\nsave(\"prior_flavors.svg\", fig); nothing # hide","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"(Image: )","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"We note three important features:","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"Normal samples can be negative.\nLognormal samples cannot be negative, but can have large positive values.\nScaledLogitNormal samples have compact support, and thus strict upper and lower bounds.","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"Boundedness is a very useful property of ScaledLogitNormal, so we explore specifying ScaledLogitNormal priors in more detail.","category":"page"},{"location":"literated/exploring_priors/#Fine-tuning-a-ScaledLogitNormal-prior","page":"Exploring Prior distributions","title":"Fine-tuning a ScaledLogitNormal prior","text":"","category":"section"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"We can tune the \"width\" of a ScaledLogitNormal by supplying the standard-deviation œÉ:","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"logit_priors = Dict(\"Narrow (œÉ = 0.1)\"                 => ScaledLogitNormal(œÉ = 0.1),\n                    \"Default (œÉ = 1)\"                  => ScaledLogitNormal(œÉ = 1),\n                    \"Weird (œÉ = 4 with bounds=(0, 1))\" => ScaledLogitNormal(œÉ = 4))\n\nfig, ax = visualize_priors(logit_priors)\nxlims!(ax, -0.1, 1.1)\nsave(\"logit_normal_widths.svg\", fig); nothing #hide","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"(Image: )","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"Smaller standard deviations produce narrower prior distributions. However, weird shapes can result when a standard deviation is specified that's larger than the bounds interval (eg œÉ > diff(bounds)). In the above example we're using the default bounds = (0, 1).","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"Another way to build ScaledLogitNormal prior is to specify a central interval and mass. This allows us to shift the center of mass relative to the bounds (here we use the default bounds=(0, 1)), and provides a slightly safer way to tune a distribution.","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"shifted_priors = Dict(\"Shifted left\"  => ScaledLogitNormal(interval=(0.2, 0.3), mass=0.9),\n                      \"Shifted right\" => ScaledLogitNormal(interval=(0.7, 0.8), mass=0.9),\n                      \"Centered\"      => ScaledLogitNormal(interval=(0.2, 0.8), mass=0.6))\n\nfig, ax = visualize_priors(shifted_priors)\nxlims!(ax, -0.1, 1.1)\nsave(\"logit_normal_shifting.svg\", fig); nothing #hide","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"(Image: )","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"The \"Centered\" case uses a mass that's proportional to the relative width spanned by interval (eg mass = diff(interval) / diff(bounds)) to produce a nearly uniform distribution within the bounds.","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"","category":"page"},{"location":"literated/exploring_priors/","page":"Exploring Prior distributions","title":"Exploring Prior distributions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#OceanTurbulenceParameterEstimation.jl-Documentation","page":"Home","title":"OceanTurbulenceParameterEstimation.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OceanTurbulenceParameterEstimation provides a framework to calibrate turbulence closure parametrizations for ocean models.","category":"page"},{"location":"library/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Documentation for OceanTurbulenceParameterEstimation.jl's public interface.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"library/public/#OceanTurbulenceParameterEstimation","page":"Public","title":"OceanTurbulenceParameterEstimation","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [OceanTurbulenceParameterEstimation]\nPrivate = false","category":"page"},{"location":"library/public/#Transformations","page":"Public","title":"Transformations","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [OceanTurbulenceParameterEstimation.Transformations]\nPrivate = false","category":"page"},{"location":"library/public/#OceanTurbulenceParameterEstimation.Transformations.Transformation-Tuple{}","page":"Public","title":"OceanTurbulenceParameterEstimation.Transformations.Transformation","text":"Transformation(; time=nothing, space=nothing, normalization=nothing)\n\nReturn a transformation that is applied on the observation. Examples include slicing the data or multiplying with weight factors to make the loss function putting more  weight in particular regions of the domain or particular times. Also, we can denote a normalization procedure applied to the data after the space- and time- transformations.\n\nSlicing is prescribed as SpaceIndices and TimeIndices. For example\n\nTransformation(time = TimeIndices(4:10))\n\nwill only keep time instances 4 to 10 from the observations. Similarly,\n\nTransformation(space = SpaceIndices(x=:, y=1:10, z=2:2:20))\n\nwill not affect the x dimension of the data, but will slice the observations in y and z as prescribed.\n\nKeyword Arguments\n\ntime: The time transformation either as a TimeIndices or as an AbstractVector of weights of same size as observations.times. If nothing is given, then, by default, the transformation ignores the first snapshot (initial state).\nspace: The space trasformation either as a SpaceIndices or as an AbstractArray of weights of same size as a snapshot of the observations.\nnormalization: The normalization that is applied to the data after space and time  transformations have been applied first.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#OceanTurbulenceParameterEstimation.Transformations.ZScore-Tuple{Any}","page":"Public","title":"OceanTurbulenceParameterEstimation.Transformations.ZScore","text":"ZScore(field_time_series::FieldTimeSeries)\n\nReturn the ZScore normalization of a FieldTimeSeries after computing its mean and its variance.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Observations","page":"Public","title":"Observations","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [OceanTurbulenceParameterEstimation.Observations]\nPrivate = false","category":"page"},{"location":"library/public/#OceanTurbulenceParameterEstimation.Observations.SyntheticObservations","page":"Public","title":"OceanTurbulenceParameterEstimation.Observations.SyntheticObservations","text":"SyntheticObservations(path; field_names,\n                      transformation = Transformation()),\n                      times = nothing,\n                      field_time_serieses = nothing,\n                      regrid_size = nothing)\n\nReturn a time series of synthetic observations generated by Oceananigans.jl's simulations gridded as Oceananigans.jl fields.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Ensemble-Simulations","page":"Public","title":"Ensemble Simulations","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [OceanTurbulenceParameterEstimation.EnsembleSimulations]\nPrivate = false","category":"page"},{"location":"library/public/#Parameters","page":"Public","title":"Parameters","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [OceanTurbulenceParameterEstimation.Parameters]\nPrivate = false","category":"page"},{"location":"library/public/#OceanTurbulenceParameterEstimation.Parameters.FreeParameters","page":"Public","title":"OceanTurbulenceParameterEstimation.Parameters.FreeParameters","text":"struct FreeParameters{N, P}\n\nA container for free parameters that includes the parameter names and their corresponding prior distributions.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#OceanTurbulenceParameterEstimation.Parameters.FreeParameters-Tuple{Any}","page":"Public","title":"OceanTurbulenceParameterEstimation.Parameters.FreeParameters","text":"FreeParameters(priors; names = Symbol.(keys(priors)))\n\nReturn named FreeParameters with priors. Free parameter names are inferred from the keys of priors if not provided.\n\nExample\n\njulia> using Distributions, OceanTurbulenceParameterEstimation\n\njulia> priors = (ŒΩ = Normal(1e-4, 1e-5), Œ∫ = Normal(1e-3, 1e-5))\n(ŒΩ = Normal{Float64}(Œº=0.0001, œÉ=1.0e-5), Œ∫ = Normal{Float64}(Œº=0.001, œÉ=1.0e-5))\n\njulia> free_parameters = FreeParameters(priors)\nFreeParameters with 2 parameters\n‚îú‚îÄ‚îÄ names: (:ŒΩ, :Œ∫)\n‚îî‚îÄ‚îÄ priors: Dict{Symbol, Any}\n    ‚îú‚îÄ‚îÄ ŒΩ => Normal{Float64}(Œº=0.0001, œÉ=1.0e-5)\n    ‚îî‚îÄ‚îÄ Œ∫ => Normal{Float64}(Œº=0.001, œÉ=1.0e-5)\n\n\n\n\n\n","category":"method"},{"location":"library/public/#OceanTurbulenceParameterEstimation.Parameters.ScaledLogitNormal","page":"Public","title":"OceanTurbulenceParameterEstimation.Parameters.ScaledLogitNormal","text":"ScaledLogitNormal([FT=Float64;] bounds=(0, 1), mass=0.5, interval=nothing)\n\nReturn a ScaledLogitNormal distribution with compact support within bounds.\n\ninterval is an optional 2-element tuple or Array. When specified, the parameters Œº and œÉ of the underlying Normal distribution are calculated so that mass fraction of the probability density lies within interval.\n\nIf interval is not specified, then Œº=0 and œÉ=1 by default.\n\nNotes\n\nScaledLogitNormal is a four-parameter distribution generated by the transformation\n\nY = L + (U - L)  1 + exp(X)\n\nof the normally-distributed variate X  ùí©(Œº œÉ). The four parameters governing the distribution of Y are thus\n\nL:  lower bound (0 for the LogitNormal distribution)\nU:  upper bound (1 for the LogitNormal distribution)\nŒº:  mean of the underlying Normal distribution\nœÉ¬≤: variance of the underlying Normal distribution\n\n\n\n\n\n","category":"type"},{"location":"library/public/#OceanTurbulenceParameterEstimation.Parameters.lognormal-Tuple{}","page":"Public","title":"OceanTurbulenceParameterEstimation.Parameters.lognormal","text":"lognormal(; mean, std)\n\nReturn Lognormal distribution parameterized by  the distribution mean and standard deviation std.\n\nNotes\n\nA variate X is LogNormal distributed if\n\nlog(X)  ùí©(Œº œÉ¬≤) \n\nwhere ùí©(Œº œÉ¬≤) is the Normal distribution with mean Œº and variance œÉ¬≤.\n\nThe mean and variance s¬≤ (where s is the standard deviation or std) are related to the parameters Œº and œÉ¬≤ via\n\n m = exp(Œº + œÉ¬≤  2)\n\ns¬≤ = exp(œÉ¬≤) - 1 m¬≤\n\nThese formula allow us to calculate Œº and œÉ given m and s¬≤, since rearranging the formula for s¬≤ gives\n\nexp(œÉ¬≤) = m¬≤  s¬≤ + 1\n\nwhich then yields\n\nœÉ = sqrtlog(m¬≤  s¬≤ + 1)\n\nWe then find that\n\nŒº = log(m) - œÉ¬≤  2 \n\nSee also wikipedia.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Inverse-Problems","page":"Public","title":"Inverse Problems","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [OceanTurbulenceParameterEstimation.InverseProblems]\nPrivate = false","category":"page"},{"location":"library/public/#OceanTurbulenceParameterEstimation.InverseProblems.InverseProblem-Tuple{Any, Any, Any}","page":"Public","title":"OceanTurbulenceParameterEstimation.InverseProblems.InverseProblem","text":"InverseProblem(observations,\n            simulation,\n            free_parameters;\n            output_map = ConcatenatedOutputMap(),\n            time_series_collector = nothing)\n\nReturn an InverseProblem.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#OceanTurbulenceParameterEstimation.InverseProblems.forward_map-Tuple{Any, Any}","page":"Public","title":"OceanTurbulenceParameterEstimation.InverseProblems.forward_map","text":"forward_map(ip, parameters)\n\nRun ip.simulation forward with parameters and return the data, transformed into an array format expected by EnsembleKalmanProcesses.jl.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#OceanTurbulenceParameterEstimation.InverseProblems.forward_run!-Tuple{InverseProblem, Any}","page":"Public","title":"OceanTurbulenceParameterEstimation.InverseProblems.forward_run!","text":"forward_run!(ip, parameters)\n\nInitialize ip.simulation with parameters and run it forward. Output is stored in ip.time_series_collector.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#OceanTurbulenceParameterEstimation.InverseProblems.observation_map-Tuple{InverseProblem}","page":"Public","title":"OceanTurbulenceParameterEstimation.InverseProblems.observation_map","text":"observation_map(ip::InverseProblem)\n\nTransform and return ip.observations appropriately for ip.output_map.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#OceanTurbulenceParameterEstimation.InverseProblems.observation_map_variance_across_time-Tuple{ConcatenatedOutputMap, SyntheticObservations}","page":"Public","title":"OceanTurbulenceParameterEstimation.InverseProblems.observation_map_variance_across_time","text":"observation_map_variance_across_time(map::ConcatenatedOutputMap, observation::SyntheticObservations)\n\nReturn an array of size (Nensemble, Ny * Nz * Nfields, Ny * Nz * Nfields) that stores the covariance of each element of the observation map measured across time, for each ensemble member, where Nensemble is the ensemble size, Ny is either the number of grid elements in y or the batch size, Nz is the number of grid elements in the vertical, and Nfields is the number of fields in observation.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#EnsembleKalmanInversions","page":"Public","title":"EnsembleKalmanInversions","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [OceanTurbulenceParameterEstimation.EnsembleKalmanInversions]\nPrivate = false","category":"page"},{"location":"library/public/#OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.EnsembleKalmanInversion-Tuple{Any}","page":"Public","title":"OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.EnsembleKalmanInversion","text":"EnsembleKalmanInversion(inverse_problem; noise_covariance=1e-2, resampler=Resampler())\n\nReturn an object that interfaces with EnsembleKalmanProcesses.jl and uses Ensemble Kalman Inversion to iteratively \"solve\" the inverse problem:\n\ny = G(Œ∏) + Œ∑\n\nfor the parameters Œ∏, where y is a \"normalized\" vector of observations, G(Œ∏) is a forward map that predicts the observations, and Œ∑  ùí©(0 Œì_y) is zero-mean random noise with covariance matrix Œì_y representing uncertainty in the observations.\n\nBy \"solve\", we mean that the iteration finds the parameter values Œ∏ that minimizes the distance between y and G(Œ∏).\n\nThe \"forward map output\" G can have many interpretations. The specific statistics that G computes have to be selected for each use case to provide a concise summary of the complex model solution that contains the values that we would most like to match to the corresponding truth values y. For example, in the context of an ocean-surface boundary layer parametrization, this summary could be a vector of  concatenated u, v, b, e profiles at all or some time steps of the CATKE solution.\n\n(For more details on the Ensemble Kalman Inversion algorithm refer to the EnsembleKalmanProcesses.jl Documentation.)\n\nArguments\n\ninverse_problem :: InverseProblem: Represents an inverse problem representing the comparison between                                      synthetic observations generated by                                      Oceananigans.jl                                      and model predictions, also generated by Oceananigans.jl.\nnoise_covariance (AbstractMatrix or Number): normalized covariance representing observational                                                    uncertainty. If noise_covariance isa Number then                                                    it's converted to an identity matrix scaled by                                                    noise_covariance.\nresampler: controls particle resampling procedure. See Resampler.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.iterate!-Tuple{EnsembleKalmanInversion}","page":"Public","title":"OceanTurbulenceParameterEstimation.EnsembleKalmanInversions.iterate!","text":"iterate!(eki::EnsembleKalmanInversion; iterations = 1, show_progress = true)\n\nIterate the ensemble Kalman inversion problem eki forward by iterations.\n\nReturn\n\nbest_parameters: the ensemble mean of all parameter values after the last iteration.\n\n\n\n\n\n","category":"method"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"EditURL = \"https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/blob/main/examples/perfect_convective_adjustment_calibration.jl\"","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/#Perfect-convective-adjustment-calibration-with-Ensemble-Kalman-Inversion","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"","category":"section"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"This example calibrates a convective adjustment model in the \"perfect model context\". In this context, synthetic observations are generated by a convective adjustment model with \"true\" parameters. The true parameters are then \"rediscovered\" by calibrating the model to match the synthetic observations.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"We use the discrepency between observed and modeled buoyancy b to calibrate the convective adjustment model. The calibration problem is solved by Ensemble Kalman Inversion. For more information about Ensemble Kalman Inversion, see the EnsembleKalmanProcesses.jl documentation.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/#Install-dependencies","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Install dependencies","text":"","category":"section"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"using Pkg\npkg\"add OceanTurbulenceParameterEstimation, Oceananigans, Distributions, CairoMakie\"","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"using OceanTurbulenceParameterEstimation, LinearAlgebra, CairoMakie","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"We reuse some some code from a previous example to generate observations,","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"examples_path = joinpath(pathof(OceanTurbulenceParameterEstimation), \"..\", \"..\", \"examples\")\ninclude(joinpath(examples_path, \"intro_to_inverse_problems.jl\"))\n\ndata_path = generate_synthetic_observations()\nobservations = SyntheticObservations(data_path, field_names=:b, transformation=ZScore())","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"and an ensemble_simulation,","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"ensemble_simulation, closure‚òÖ = build_ensemble_simulation(observations; Nensemble=50)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"The handy utility function build_ensemble_simulation also tells us the optimal parameters that were used when generating the synthetic observations:","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"@show Œ∏‚òÖ = (convective_Œ∫z = closure‚òÖ.convective_Œ∫z, background_Œ∫z = closure‚òÖ.background_Œ∫z)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/#The-InverseProblem","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"The InverseProblem","text":"","category":"section"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"To build an inverse problem we first define free parameters. Here we calibrate convective_Œ∫z and background_Œ∫z, using log-normal priors to prevent the parameters from becoming negative:","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"priors = (convective_Œ∫z = lognormal(mean=0.3, std=0.5),\n          background_Œ∫z = lognormal(mean=2.5e-4, std=2.5e-5))\n\nfree_parameters = FreeParameters(priors)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"The InverseProblem is then constructed from observations, ensemble_simulation, and free_parameters,","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"calibration = InverseProblem(observations, ensemble_simulation, free_parameters)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"For more information about the above steps, see Intro to observations and Intro to InverseProblem.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/#Ensemble-Kalman-Inversion","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"","category":"section"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"Next, we construct an EnsembleKalmanInversion (EKI) object,","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"The calibration is done here using Ensemble Kalman Inversion. For more information about the algorithm refer to EnsembleKalmanProcesses.jl documentation.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"eki = EnsembleKalmanInversion(calibration; noise_covariance = 1e-2)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"and perform few iterations to see if we can converge to the true parameter values.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"iterate!(eki; iterations = 10)","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"Last, we visualize the outputs of EKI calibration.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"Œ∏ÃÖ(iteration) = [eki.iteration_summaries[iteration].ensemble_mean...]\nvarŒ∏(iteration) = eki.iteration_summaries[iteration].ensemble_var\n\nweight_distances = [norm(Œ∏ÃÖ(iter) - [Œ∏‚òÖ[1], Œ∏‚òÖ[2]]) for iter in 0:eki.iteration]\noutput_distances = [norm(forward_map(calibration, Œ∏ÃÖ(iter))[:, 1] - y) for iter in 0:eki.iteration]\nensemble_variances = [varŒ∏(iter) for iter in 0:eki.iteration]\n\nf = Figure()\n\nlines(f[1, 1], 0:eki.iteration, weight_distances, color = :red, linewidth = 2,\n      axis = (title = \"Parameter distance\",\n              xlabel = \"Iteration\",\n              ylabel = \"|Œ∏ÃÖ‚Çô - Œ∏‚òÖ|\"))\n\nlines(f[1, 2], 0:eki.iteration, output_distances, color = :blue, linewidth = 2,\n      axis = (title = \"Output distance\",\n              xlabel = \"Iteration\",\n              ylabel = \"|G(Œ∏ÃÖ‚Çô) - y|\"))\n\nax3 = Axis(f[2, 1:2],\n           title = \"Parameter convergence\",\n           xlabel = \"Iteration\",\n           ylabel = \"Ensemble variance\",\n           yscale = log10)\n\nfor (i, pname) in enumerate(free_parameters.names)\n    ev = getindex.(ensemble_variances, i)\n    lines!(ax3, 0:eki.iteration, ev / ev[1], label = String(pname), linewidth = 2)\nend\n\naxislegend(ax3, position = :rt)\n\nsave(\"summary_convective_adjustment_eki.svg\", f); nothing #hide","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"And also we plot the the distributions of the various model ensembles for few EKI iterations to see if and how well they converge to the true diffusivity values.","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"f = Figure()\n\naxtop = Axis(f[1, 1])\n\naxmain = Axis(f[2, 1],\n              xlabel = \"convective_Œ∫z [m¬≤ s‚Åª¬π]\",\n              ylabel = \"background_Œ∫z [m¬≤ s‚Åª¬π]\")\n\naxright = Axis(f[2, 2])\nscatters = []\nlabels = String[]\n\nfor iteration in [0, 1, 2, 10]\n    # Make parameter matrix\n    parameters = eki.iteration_summaries[iteration].parameters\n    Nensemble = length(parameters)\n    Nparameters = length(first(parameters))\n    parameter_ensemble_matrix = [parameters[i][j] for i=1:Nensemble, j=1:Nparameters]\n\n    label = iteration == 0 ? \"Initial ensemble\" : \"Iteration $iteration\"\n    push!(labels, label)\n    push!(scatters, scatter!(axmain, parameter_ensemble_matrix))\n    density!(axtop, parameter_ensemble_matrix[:, 1])\n    density!(axright, parameter_ensemble_matrix[:, 2], direction = :y)\nend\n\nvlines!(axmain, [Œ∏‚òÖ.convective_Œ∫z], color = :red)\nvlines!(axtop, [Œ∏‚òÖ.convective_Œ∫z], color = :red)\n\nhlines!(axmain, [Œ∏‚òÖ.background_Œ∫z], color = :red)\nhlines!(axright, [Œ∏‚òÖ.background_Œ∫z], color = :red)\n\ncolsize!(f.layout, 1, Fixed(300))\ncolsize!(f.layout, 2, Fixed(200))\nrowsize!(f.layout, 1, Fixed(200))\nrowsize!(f.layout, 2, Fixed(300))\n\nLegend(f[1, 2], scatters, labels, position = :lb)\n\nhidedecorations!(axtop, grid = false)\nhidedecorations!(axright, grid = false)\n\nxlims!(axmain, -0.25, 3.2)\nxlims!(axtop, -0.25, 3.2)\nylims!(axmain, 5e-5, 35e-5)\nylims!(axright, 5e-5, 35e-5)\n\nsave(\"distributions_convective_adjustment_eki.svg\", f); nothing #hide","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"(Image: )","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"","category":"page"},{"location":"literated/perfect_convective_adjustment_calibration/","page":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","title":"Perfect convective adjustment calibration with Ensemble Kalman Inversion","text":"This page was generated using Literate.jl.","category":"page"}]
}
